//
// Quake game definition file (.fgd)
// for Worldcraft 1.6 and above
//
// written by autolycus / autolycus@planetquake.com
// email me with improvements and suggestions
//

// Modified by CZG : grawert@online.no : http://www.planetquake.com/greyvoid/

// Modified by Vigil for Rubicon 2
// Download Rubicon 2 from http://www.celephais.net
// Rubicon 2 created by John "metlslime" Fitzgibbons and Christian "CZG" Grawert
// Entity comments mostly copied from metlslime's rubicon2.def

//
// worldspawn
//

@SolidClass = worldspawn : "World entity"
[
	message(string) : "Text on entering the world"
	worldtype(choices) : "Ambience" : 0 =
	[
		0 : "Medieval"
		1 : "Runic (metal)"
		2 : "Present (base)"
	]
	sounds(integer) : "CD track to play" : 1
	light(integer) : "Ambient light"
	sky(string) : "Skybox"
	
	_dirt(integer) : "Use dirtmapping (ambient occlusion)" : 0
	_bounce(integer) : "Bounce Lighting" : 0 : "1 enables bounce lighting, default 0."
	_bouncestyled(integer) : "Bounce Styled Lights" : 0 : "1 makes styled lights bounce (e.g. flickering or switchable lights), default is 0, they do not bounce."
	
	_sunlight(integer) : "Sunlight"
	_sun_mangle(string) : "Sun mangle (Yaw pitch roll)"
	_sunlight_penumbra(integer) : "Sunlight Penumbra" : : "Specifies the penumbra width, in degrees, of sunlight. Useful values are 3-4 for a gentle soft edge, or 10-20+ for more diffuse sunlight." 
	_sunlight_color(color255) : "Sunlight Color" :  : "Specify the red(r), green(g) and blue(b) components for the colour of the sunlight. Default is white(255 255 255)." 
	_sunlight2(integer) : "Set the brightness of a dome of lights arranged around the upper hemisphere. (i.e. ambient light, coming from above the horizon). Default 0."
	_sunlight2_color(color255) : "Sunlight 2 color" :  : "Specifies the color of '_sunlight2', same format as '_sunlight_color'. Default (255 255 255)"
	_sunlight3(integer) : "Sunlight 3" :  : "Same as _sunlight2, but for the bottom hemisphere, where ambient light is coming from below the horizon. Combine '_sunlight2' and '_sunlight3' to have light coming equally from all directions. Useful in levels with a Sky/Void theme. Default 0."
	_sunlight3_color(color255) : "Sunlight 3 color" :  : "Specifies the color of '_sunlight3', same format as '_sunlight_color'. Default (255 255 255)"

	fog(string) : "Fog Command" :  : "ENGINE only 'console command' for setting fog parameters, Density/R/G/B example = (0.05 0.3 0.3 0.3)."
	fog_density(float) : "Fog Density" :  : "Global fog density (def 0.1)."
	fog_colour(color1) : "Fog Colour" :  : "Initial global fog colour (def 0.1 0.1 0.1)."
]

//
// base marker definitions
//

@BaseClass = Appearflags [
	spawnflags(Flags) =
	[
		256 : "Not in Easy" : 0
		512 : "Not in Normal" : 0
		1024 : "Not in Hard" : 0
		2048 : "Not in Deathmatch" : 0
	]
]

@BaseClass = Targetname [ targetname(target_source) : "Name" ]
@BaseClass = Target [ 
	target(target_destination) : "Target" 
	killtarget(target_destination) : "Killtarget"
]


@BaseClass color(255 255 40) = Light [
	light(integer) : "Brightness" : 300
	wait(float) : "Fade distance multiplier" : "1"
	_color(color) : "Light color"
	mangle(string) : "Spotlight angle"
	angle(integer) : "Spotlight angle width" : 40
	_softangle(float) : "Inner spotlight angle width" : "0"
	delay(choices) : "Attenuation" =
	[
		0 : "Linear falloff (Default)"
		1 : "Inverse distance falloff"
		2 : "Inverse distance squared"
		3 : "No falloff"
	]
	style(choices) : "Animated light style" : 0 =
	[
		0 : "Normal"
		10: "Fluorescent flicker"
		2 : "Slow, strong pulse"
		11: "Slow pulse, noblack"
		5 : "Gentle pulse"
		1 : "Flicker A"
		6 : "Flicker B"
		3 : "Candle A"
		7 : "Candle B"
		8 : "Candle C"
		4 : "Fast strobe"
		9 : "Slow strobe"
	]

	spawnflags(Flags) = [ 1 : "Initially dark" : 0 ]
]

@BaseClass = ModelLight	[
	_minlight(integer) : "Min light" :  : "Set the minimum light level for any surface of the brush model. Default 0"
	_mincolor(color255) : "Min light color R G B" : "255 255 255" : "Specify red(r), green(g) and blue(b) components for the colour of the minlight. RGB component values are between 0 and 255 (between 0 and 1 is also accepted). Default is white light (255 255 255)"
	_shadow(integer) : "Shadows" :  : "If n is 1, this model will cast shadows on other models and itself (i.e. '_shadow' implies '_shadowself'). Note that this doesn’t magically give Quake dynamic lighting powers, so the shadows will not move if the model moves. Func_detail ONLY - If set to -1, light will pass through this brush model. Default 0"
	_shadowself(integer) : "Self Shadow" :  : "If n is 1, this model will cast shadows on itself if one part of the model blocks the light from another model surface. This can be a better compromise for moving models than full shadowing. Default 0"
	_dirt(integer) : "Dirt mapping (override)" :  : "For brush models, -1 prevents dirtmapping on the brush model. Useful it the bmodel touches or sticks into the world, and you want to those ares from turning black. Default 0"
	_phong(choices) : "Enable Phong shading" : 0 =
	[
		0: "No"
		1: "Yes"
	]
	_phong_angle(integer) : "Phong shading angle" :  : "Enables phong shading on faces of this model with a custom angle. Adjacent faces with normals this many degrees apart (or less) will be smoothed. Consider setting '_anglescale' to '1' on lights or worldspawn to make the effect of phong shading more visible. Use the '-phongdebug' command-line flag to save the interpolated normals to the lightmap for previewing (use 'r_lightmap 1' or 'gl_lightmaps 1' in your engine to preview.)"
]

@BaseClass = Alpha [
	alpha(float) : "Opacity" : "1.0" : "Controls entity opacity in the 0-1 range. 0: fully transparent, 1: fully opaque"
]

@BaseClass = Angle [
	angle(integer) : "Angle"
]


@baseclass = Fog [ 
	fog_density(string) : "Fog Density" 
	fog_color(color1) : "Fog Color" 
]
@baseclass = FogShift [ 
	fog_density(string) : "Start Fog Density" 
	fog_color(color1) : "Start Fog Color" 
	fog_density2(string) : "End Fog Density" 
	fog_color2(color1) : "End Fog Color" 
]


//
// Rubicon 2 specific additions
// New enemies have been added to the monster section
//

@SolidClass base(Appearflags, Targetname, Target) color(255 128 128) = func_explobox : 
"An exploding brush entity. Works just like misc_explobox." 
[
	health(integer) : "Health" : 20
	dmg(integer) : "Damage" : 100
	spawnflags(flags)=
	[
		1 : "Start off" : 0
	]
]

@SolidClass base(Appearflags, Targetname, Target) color(255 128 128) = func_breakable : 
"A visible object that can be destroyed by shooting it. If it has a targetname, it will not be directly damageable.

NO_MONSTERS: object ignores damage from monsters" 
[
	cnt(integer) : "Debris amount" : 6 : "Number of pieces of debris to spawn."
	health(integer) : "Health" : 20
	style(choices) : "Debris color" : 0 = 
	[
        0: "Green metal"
		1: "Red metal"
		2: "Concrete"
	]
	spawnflags(flags) =
	[
		1 : "No monsters" : 0
	]
]

// FUNC_LASER
// toggleable laser, damages on touch

@SolidClass base(Appearflags, Targetname, Target) color(255 128 128) = func_laser : 
"A togglable laser, hurts to touch, can be used to block players." 
[
	dmg(integer) : "Damage" : 1
	alpha(float) : "Opacity" : "0.5" : "Approximate alpha you want the laser drawn at. default 0.5. alpha will vary by 20% of this value."
	message(string) : "Activated message"
	message2(string) : "Deactivated message"
	spawnflags(flags) =
	[
		1 : "Starts off" : 0
		2 : "Solid" : 0
	]
]

@SolidClass base(Appearflags, Targetname, Target) color(255 255 128) = func_turret : 
"A rotating laser shooter that aims at the player in any horizontal direction. Has a capped rotation speed based on skill setting. When triggered, toggles between active and inactive states.
START_OFF spawns in the inactive state.
Place in the level in the active/attacking position for proper lighting.
See Rubicon 2 for examples of use." 
[
	movedir(string) : "Active to start_off" : : "the offset from active position to the initial START_OFF position"
	movedir2(string) : "Active to deactive" : : "the offset from the active position to the deactivated position (after being previously active)"
	height(integer) : "Height" : 32 : "the position that laser originates, measured up from the very bottom of the model"
	speed(integer) : "Speed" : 100 : "speed when moving to a new position"
	sounds(choices) : "Sound" : 0 = 
	[
        0: "No sounds"
		1: "Stone"
		2: "Machine"
		3: "Stone Chain"
		4: "Screechy Metal"
	]
	spawnflags(flags) =
	[
		1 : "Starts off" : 0
	]
]


@SolidClass base(Appearflags, Targetname, Target) color(128 128 64) = trigger_ladder :
"Invisible ladder entity.
When player is touching this entity, he can climb by pushing 'jump'."
[
	angle(integer) : "Angle" : : "The direction player must be facing to climb ladder"
]

@PointClass base(Appearflags, Targetname, Target) color(0 128 0) size(-4 -4 -4, 4 4 4) = info_rotate : 
"Used as the point of rotation for rotatable objects." []

@SolidClass base(Appearflags, Targetname, Target) color(0 0 255) = func_movewall : 
"Used to emulate collision on rotating objects.
'Visible' causes brush to be displayed.
'Hurts' specifies whether to cause damage when touched by player.
'Non-solid' makes the brush non-solid.  This is useless if VISIBLE is set."
[
	dmg(integer) : "Damage" : 0
	spawnflags(flags) =
	[
		1 : "Visible" : 0
		2 : "Hurts" : 0
		4 : "Non-solid" : 0
	]
]

@SolidClass base(Appearflags, Targetname, Target) color(64 128 64) = func_rotate_door : 
"Creates a door that rotates between two positions around a point of rotation each time it's triggered.

STAYOPEN tells the door to reopen after closing.  This prevents a trigger-once door from closing again when it's blocked."
[
	dmg(integer) : "Damage" : 2 : "Specifies the damage to cause when blocked. Negative numbers indicate no damage."
	speed(integer) : "Speed" : 100 : "Specifies the time it takes to rotate."
	sounds(choices) : "Sound" =
	[
		0: "No sounds"
		1: "Stone"
		2: "Machine"
		3: "Stone Chain"
		4: "Screechy Metal"
	]
	spawnflags(flags) =
	[
		1 : "Stay open" : 0
	]
]

@SolidClass base(Appearflags, Targetname) color(64 128 64) = func_rotate_entity : 
"Creates an entity that continually rotates.  Can be toggled on and off if targeted."
[
	deathtype(string) : "Death message"
	rotate(integer) : "Speed" : 40
	target(string) : "Center of rotation"
	speed(integer) : "Acceleration" : 5 : "How long the entity takes to go from standing still to full speed and vice-versa."
	spawnflags(flags) =
	[
		1 : "Toggle" : 0
		2 : "Start on" : 0
	]
]


@SolidClass base(Appearflags, Targetname, Target) color(64 128 64) = func_rotate_train : 
"In path_rotate, set speed to be the new speed of the train after it reaches
the path change.  If speed is -1, the train will warp directly to the next
path change after the specified wait time.  If MOVETIME is set on the
path_rotate, the train to interprets 'speed' as the length of time to
take moving from one corner to another.

Both noise and noise1 defaults depend upon 'sounds' variable and
can be overridden by the 'noise' and 'noise1' variable in path_rotate.

Also in path_rotate, if STOP is set, the train will wait until it is
retriggered before moving on to the next goal.

Trains are moving platforms that players can ride.
'path' specifies the first path_rotate and is the starting position.
If the train is the target of a button or trigger, it will not begin moving until activated.
The func_rotate_train entity is the center of rotation of all objects targeted by it."
[
	noise(string) : "Stop sound"
	noise1(string) : "Start sound"
	sounds(choices) : "Sound" =
	[
		0 : "No sounds"
		1 : "Ratchet metal"
	]
	deathtype(string) : "Death message"
	speed(integer) : "Speed" : 100
	dmg(integer) : "Damage if blocked" : 0
	path(target_destination) : "Target path_rotate" : : "First path_rotate which will be the starting position"
]


@PointClass base(Appearflags, Targetname, Target) color(128 64 0) size(8 8 8) = path_rotate :
"Path for rotate_train.

ROTATION tells train to rotate at rate specified by 'rotate'.  Use '0 0 0' to stop rotation.

ANGLES tells train to rotate to the angles specified by 'angles' while traveling to this path_rotate.  Use values < 0 or > 360 to guarantee that it turns in a certain direction.  Having this flag set automatically clears any rotation.

STOP tells the train to stop and wait to be retriggered.

NO_ROTATE tells the train to stop rotating when waiting to be triggered.

DAMAGE tells the train to cause damage based on 'dmg'.

MOVETIME tells the train to interpret 'speed' as the length of time to take moving from one corner to another.

SET_DAMAGE tells the train to set all targets damage to 'dmg'

'noise' contains the name of the sound to play when train stops.
'noise1' contains the name of the sound to play when train moves.
'event' is a target to trigger when train arrives at path_rotate."
[
	spawnflags(flags) =
	[
		1 : "Rotation" : 0
		2 : "Angles" : 0
		4 : "Stop" : 0
		8 : "Waiting" : 0
		16 : "Damaging" : 0
		32 : "Movetime" : 0
		64 : "Target dmg" : 0
	]
	rotate(string) : "Speed (X Y Z)"
	angles(string) : "Angles (X Y Z)"
	dmg(integer) : "Damage" : 0
	noise(string) : "Stop sound"
	noise1(string) : "Start sound"
	event(string) : "Event target"
]

@PointClass base(Appearflags, Targetname, Target) color(0 128 204) = rotate_object :
"This defines an object to be rotated.  Used as the target of func_rotate_door." []


//
// player starts, deathmatch, coop, teleport
//

@BaseClass base(Appearflags, Fog) size(-16 -16 -24, 16 16 32) 
	color(0 255 0) model({"path" :"progs/player.mdl"}) = PlayerClass [
		angle(integer) : "Angle"
	]

@PointClass base(PlayerClass) = info_player_start : "Player 1 start" []
@PointClass base(PlayerClass) = info_player_coop : "Player cooperative start" []
@PointClass base(PlayerClass) = info_player_start2 : "Player episode return point" []
@PointClass base(PlayerClass) = info_player_deathmatch : "DM start" []
@PointClass size(-16 -16 0, 16 16 64) base(Targetname, Fog) = info_teleport_destination : "Teleport destination" []
@PointClass = info_null : "info_null (spotlight target)"
[
	targetname(target_source) : "Name" 
]

@PointClass base(Target, Targetname) = info_notnull : "info_notnull" // I <3 you
[
	use(string) : "self.use"
	think(string) : "self.think"
	nextthink(integer) : "nextthink"
	noise(string) : "noise"
	wait(float) : "wait"
]
@PointClass base(Appearflags) = info_intermission : "Intermission camera" 
[
	mangle(string) : "Mangle (Pitch Yaw Roll)"
]

//
// items
//


@BaseClass base(Appearflags, Target, Targetname) =
	NonRespawnableItem
[
	spawnflags(flags) =
	[
		32 : "Spawn silent" : 0
		64 : "Trigger spawned" : 0
		128 : "Suspended in air" : 0
	]
	// message(string) : "Message"
	// delay(integer) : "Delay"
]

@BaseClass base(NonRespawnableItem) =
	RespawnableItem
[
	spawnflags(flags) =
	[
		16384 : "Respawn with DM effects" : 0
	]
	ritem(integer) : "Respawn item if set to 1"
	respawndelay(integer) : "Respawn time"
	respawncount(integer) : "How many respawns?"
]

@BaseClass size(0 0 0, 32 32 56) color(80 0 200) base(RespawnableItem, Appearflags) = Ammo
[
	spawnflags(flags) = 
	[
		1 : "Large box" : 0
	]
]

@PointClass base(Ammo) model(
        {{
            spawnflags & 1 ->   ":maps/b_batt1.bsp",
                                ":maps/b_batt0.bsp"
        }}
    ) = item_cells : "Thunderbolt ammo" []
@PointClass base(Ammo) model(
        {{
            spawnflags & 1 ->   ":maps/b_rock1.bsp",
                                ":maps/b_rock0.bsp"
        }}
    ) = item_rockets : "Rockets" []
@PointClass base(Ammo) model(
        {{
            spawnflags & 1 ->   ":maps/b_shell1.bsp",
                                ":maps/b_shell0.bsp"
        }}
    ) = item_shells : "Shells" []
@PointClass base(Ammo) model(
        {{
            spawnflags & 1 ->   ":maps/b_nail1.bsp",
                                ":maps/b_nail0.bsp"
        }}
    ) = item_spikes : "Perforator/Nailgun ammo" []

@PointClass size(0 0 0, 32 32 56) base(RespawnableItem, Appearflags) model(
        {{
            spawnflags & 2 ->   ":maps/b_bh100.bsp",
            spawnflags & 1 ->   ":maps/b_bh10.bsp",
                                ":maps/b_bh25.bsp"
        }}
    ) = item_health : "Health pak" 
[
	spawnflags(flags) = 
	[
		1 : "Rotten" : 0
		2 : "Megahealth" : 0
	]
]

@PointClass size(-16 -16 -24, 16 16 32) base(RespawnableItem, Appearflags) model({ "path": ":progs/suit.mdl" }) =
	item_artifact_envirosuit : "Environmental protection suit" []
@PointClass size(-16 -16 -24, 16 16 32) base(RespawnableItem, Appearflags) model({ "path": ":progs/quaddama.mdl" }) =
	item_artifact_super_damage : "Quad damage" []
@PointClass size(-16 -16 -24, 16 16 32) base(RespawnableItem, Appearflags) model({ "path": ":progs/invulner.mdl" }) =
	item_artifact_invulnerability : "Pentagram of Protection" []
@PointClass size(-16 -16 -24, 16 16 32) base(RespawnableItem, Appearflags) model({ "path": ":progs/invisibl.mdl" }) =
	item_artifact_invisibility : "Ring of Shadows" []


@PointClass size(-16 -16 0, 16 16 56) base(RespawnableItem, Appearflags) model({ "path": ":progs/armor.mdl", "skin": 2 }) =
	item_armorInv : "Red armor (200%)" []
@PointClass size(-16 -16 0, 16 16 56) base(RespawnableItem, Appearflags) model({ "path": ":progs/armor.mdl", "skin": 1 }) =
	item_armor2 : "Yellow armor (150%)" []
@PointClass size(-16 -16 0, 16 16 56) base(RespawnableItem, Appearflags) model({ "path": ":progs/armor.mdl" }) =
	item_armor1 : "Green armor (100%)" []


@BaseClass base(NonRespawnableItem) size(-16 -16 -24, 16 16 32) =
	Key []

@PointClass base(Key) model({ "path": ":progs/w_s_key.mdl" }) =
	item_key1 : "Silver key" []
@PointClass base(Key) model({ "path": ":progs/w_g_key.mdl" }) =
	item_key2 : "Gold key" []

@PointClass base(Key) model({ "path": mdl, "skin": skin }) =
	item_key_custom :
"A customizable key item.

This allows mappers to use any Quake compatible model, sprite or BSP as a key. We’ve also included new key models with different variations. You can find these in the progs folder and set their paths in the mdl key.

keyname: name of the key, e.g. 'bronze key' (required), mdl: model file path (required) noise: sound file for the pickup sound (default is per worldtype), skin: skin index (default 0), frame (default 0): display this single frame of the model, if animated. NOTE: The key will not display any animation.

Three new models based on id’s original keys are included. One for each worldtype: base, runic and wizard. Each of these has four color variations, also referred to as their skin index: jade (green, skin 0), runic (magenta, skin 1), blood (red, skin 2) and alabaster (gray, skin 3). The development/wads folder has a small wad with textures for use with the different styles seen below.

'keyname': name of the key, e.g. 'bronze key' (required)

'mdl': model file (required)

'noise': sound file for the pickup sound (default is per worldtype)

'skin': skin index (default 0)

The 'keyname' value is used both for the pickup message and to associate the key with the entity that it unlocks.

To make a func_door or trigger_usekey require this key, set the 'keyname' value of that entity so that it matches the 'keyname' value of the key.

If different item_key_custom entities have the same 'keyname' value, they will be treated as different copies of the same key and may be used interchangeably.

A map may have a maximum of 23 unique 'keyname' values across all entities.

The behavior of an item_key_custom should be as the player expects (based on the behavior of the silver and gold keys), except for the fact that it will not appear as an icon in the player's status bar when picked up.  This is a limitation of the engine."
[
	keyname(string) : "Name of the key, e.g. 'bronze key' (required)"
	mdl(string) : "Model file (required)"
	noise(string) : "Sound file for the pickup sound (default is per worldtype)"
	skin(integer) : "Skin index (default 0)"
]


@PointClass size(-16 -16 -24, 16 16 32) base(NonRespawnableItem, Appearflags) model({ "path": ":progs/end1.mdl" }) =
	item_sigil : "Sigil"
[
	spawnflags(Flags) =
	[
		1 : "Episode 1" : 1
		2 : "Episode 2" : 0
		4 : "Episode 3" : 0
		8 : "Episode 4" : 0
	]
]

// ITEM_CIRCUITBOARD
// Collectible circuit board thingie

@PointClass base(Appearflags, Targetname, Target, RespawnableItem) color(255 255 32) = item_circuitboard : "Circuit board" []


//
// weaponses
// added shotgun & axe for Rubicon 2
//

@BaseClass size(-16 -16 0, 16 16 56) color(128 128 255) base(RespawnableItem, Appearflags) = Weapon []

@PointClass base(Weapon) model({"path": "progs/g_axe.mdl"}) = weapon_axe : "Axe." []
@PointClass base(Weapon) model({"path": "progs/g_shotgn.mdl"}) = weapon_shotgun : "Shotgun." []
@PointClass base(Weapon) model({"path": "progs/g_shot.mdl"}) = weapon_supershotgun : "Super shotgun" []
@PointClass base(Weapon) model({"path": "progs/g_nail.mdl"}) = weapon_nailgun : "Nailgun" []
@PointClass base(Weapon) model({"path": "progs/g_nail2.mdl"}) = weapon_supernailgun : "Perforator" []
@PointClass base(Weapon) model({"path": "progs/g_rock.mdl"}) = weapon_grenadelauncher : "Grenade launcher" []
@PointClass base(Weapon) model({"path": "progs/g_rock2.mdl"}) = weapon_rocketlauncher : "Rocket launcher" []
@PointClass base(Weapon) model({"path": "progs/g_light.mdl"}) = weapon_lightning : "Thunderbolt" []
@PointClass base(Weapon) model({"path": "progs/g_laserg.mdl"}) = weapon_laser_gun : "Laser Cannon" []

//
// badasses
// added enemies for Rubicon 2
//

@BaseClass base(Appearflags, Target, Targetname) color(192 64 64) = Monster 
[
	spawnflags(Flags) = 
	[
		1 : "Ambush" : 0
		32 : "Spawn Angry" : 0
		64 : "Trigger Spawned" : 0
		128 : "Silent Spawn" : 0
	]
]

// Rubicon 2 monsters first
// Centurion, 150 hp
@PointClass base(Monster) size(-32 -32 -24, 32 32 64) model({"path":"progs/cent.mdl"})= monster_centurion : "Centurion, 150 health points." []
// Dreadnaught, 150 hp
@PointClass base(Monster) size(-16 -16 -24, 16 16 40) model({"path":"progs/dread.mdl"}) = monster_dreadnaught : "Dreadnaught, 150 health points." []

@PointClass base(Appearflags, Target, Targetname) size(-32 -32 -24, 32 32 64) model({"path":"progs/floyd.mdl"}) = monster_floyd : "Floyd automaton robot, 200 hp
ROLLING Floyd is on his back and helpless, explodes after taking 75 damage
ASLEEP Floyd will not respond to anything unless he is shot or his targetname is triggered"
[
	spawnflags(flags) =
	[
		1 : "Ambush" : 0
		2 : "Rolling" : 0
		4 : "Asleep" : 0
	]
]

// Regular monsters
		
@PointClass base(Monster) size(-16 -16 -24, 16 16 40) model({"path":"progs/soldier.mdl"}) = monster_army :
"Grunt, 30 health points." []

@PointClass base(Monster) size(-32 -32 -24, 32 32 40) model({"path":"progs/dog.mdl"}) = monster_dog :
"Dog (Rottweiler), 25 health points." []

@PointClass base(Monster) size(-32 -32 -24, 32 32 64) model({"path":"progs/ogre.mdl"}) = monster_ogre :
"Ogre, 200 health points." []

@PointClass base(Monster) size(-32 -32 -24, 32 32 64) model({"path":"progs/ogrem.mdl"}) = monster_ogre_marksman :
"Ogre Marksman, 200 health points." []

@PointClass base(Monster) size(-16 -16 -24, 16 16 40) model({"path":"progs/knight.mdl"}) = monster_knight :
"Knight, 75 health points." []

@PointClass base(Monster) size(-16 -16 -24, 16 16 40) model({"path":"progs/hknight.mdl"}) = monster_hell_knight :
"Sabre Knight, 250 health points." []

@PointClass base(Monster) size(-16 -16 -24, 16 16 40) model({"path":"progs/wizard.mdl"}) = monster_wizard :
"Scrag (Wizard), 80 health points." []

@PointClass base(Monster) size(-32 -32 -24, 32 32 64) model({"path":"progs/demon.mdl"}) = monster_demon1 :
"Fiend (Demon), 300 health points." []

@PointClass base(Monster) size(-32 -32 -24, 32 32 64) model({"path":"progs/shambler.mdl"}) = monster_shambler :
"Shambler, 600 health points.
Rockets only have half damage
when hitting the Shambler." []

@PointClass base(Monster) size(-128 -128 -24, 128 128 256) model({"path":"progs/boss.mdl"}) = monster_boss :
"Chthon (Boss of Shareware Quake)
Only event_lightning can kill him." []

@PointClass base(Monster) size(-16 -16 -24, 16 16 40) model({"path":"progs/enforcer.mdl"}) = monster_enforcer :
"Enforcer, 80 health points." []

@PointClass base(Monster) size(-32 -32 -24, 32 32 48) model({"path":"progs/shalrath.mdl"}) = monster_shalrath :
"Vore (Shalrath), 400 health points." []

@PointClass base(Monster) size(32 32 48) model({"path":"progs/tarbaby.mdl"}) = monster_tarbaby :
"Spawn (Tarbaby), 80 health points." []

@PointClass base(Monster) size(32 32 48) model({"path":"progs/fish.mdl"}) = monster_fish :
"Rotfish, 25 health points." []

@PointClass base(Monster) size(-16 -16 -24, 16 16 32) model({"path":"progs/oldone.mdl"}) = monster_oldone :
"Shub-Niggurath, 40000 health points.
Most likely killed by teleport frag." []

@PointClass base(Monster) size(-16 -16 -24, 16 16 32) model({"path":"progs/zombie.mdl"}) = monster_zombie :
"Zombie, 60 health points.
If crucified, stick the bounding box 12 pixels back into a wall to look right." 
[
	spawnflags(Flags) = 
	[
		1 : "Crucified" : 0
		2 : "Ambush" : 0
	]
]



@PointClass base(Monster) size(-16 -16 -24, 16 16 40) model({"path":"progs/enforce3.mdl"}) = monster_super_enforcer :
"Lieutenant, 120 health points, 1000 armor.
This S.O.B. will turn you into Swiss cheese
if you are not careful!" []

@PointClass base(Monster) size(-16 -16 -24, 16 16 40) model({"path":"progs/enforce2.mdl"}) = monster_me :
"Mega Enforcer, 150 health points.
With a force field, plasma gun, and shoulder
cannon, look out for this cold-blooded killer." []

@PointClass base(Monster) size(-16 -16 -24, 16 16 40) model({"path":"progs/soldier.mdl", "skin": 1}) = monster_nailgrunt :
"Nail Grunt, 30 health points.
This ugly cyborg can penetrate your heart
...and not in a good way." []

@PointClass base(Monster) size(-16 -16 -24, 16 16 40) model({"path":"progs/axegrunt.mdl"}) = monster_axegrunt :
"Axe Grunt, 30 health points." []

@PointClass base(Monster) size(-32 -32 -24, 32 32 64) model({"path":"progs/scor.mdl"}) = monster_scourge :
"Centroid, 300 health points." []

@PointClass base(Monster) size(-48 -48 -24, 48 48 84) model({"path":"progs/armalegs.mdl"}) = monster_armagon :
"Armagon, 2000-3500 health points.
The big boss mam!" []

@PointClass base(Monster) size(-32 -32 -24, 32 32 64) model({"path":"progs/ogreb.mdl"}) = monster_ogreb :
"Berserker, 200 health points.
Don't shake hands with this crazy bastard!" []

@PointClass base(Monster) size(-16 -16 -24, 16 16 40) model({"path":"progs/drone1.mdl"}) = monster_drone :
"Drone, 100 health points." []

@PointClass base(Monster) size(-32 -32 -24, 32 32 64) model({"path":"progs/hunter.mdl"}) = monster_hunter :
"Hunter, maybe 375 health points." []

@PointClass base(Monster) size(32 32 48) model({"path":"progs/eel2.mdl"}) = monster_eel :
"Eel, 25 health points." []

@PointClass base(Monster) size(-16 -16 -24, 16 16 40) model({"path":"progs/frogman.mdl"}) = monster_frogman :
"Frogman, 100 health points." []

@PointClass base(Monster) size(-32 -32 -24, 32 32 64) model({"path":"progs/banlegs.mdl"}) = monster_banshee :
"Banshee Mech, 1300 health points." []

@PointClass base(Monster) size(-32 -32 -24, 32 32 64) model({"path":"progs/ridlegs.mdl"}) = monster_rider :
"Takahiro Raiders, 600 health points." []

@PointClass base(Monster) size(-32 -32 -24, 32 32 64) model({"path":"progs/probebod.mdl"}) = monster_probe :
"Probe, 200 health points." []

//
// lights
//

@BaseClass = LightTarget [
	target(string) : "Target" : : "Makes this light a spot light. This should be an entity for the spot line to point at (usually a info_null)"
]

@PointClass size(-8 -8 -8, 8 8 8) base(Light, LightTarget, Targetname) = light : "Invisible lightsource"	[]
@PointClass size(-8 -8 -8, 8 8 8) base(Light, LightTarget, Targetname) = light_fluoro : "Fluorescent light" []
@PointClass size(-8 -8 -8, 8 8 8) base(Light, LightTarget, Targetname) = light_fluorospark : "Sparking fluorescent light" []
@PointClass size(-8 -8 -8, 8 8 8) base(Light, LightTarget, Targetname) = light_globe : "Globe light" []

@PointClass size(-8 -8 -12, 8 8 20) base(Light, LightTarget, Targetname) model({ "path": ":progs/flame2.mdl", "frame": 1 }) = light_flame_large_yellow :
"Large yellow flame" []
@PointClass size(-4 -4 -12, 4 4 20) base(Light, LightTarget, Targetname) model({ "path": ":progs/flame2.mdl" }) = light_flame_small_yellow :
"Small yellow flame" []
@PointClass size(-4 -4 -12, 4 4 20) base(Light, LightTarget, Targetname) model({ "path": ":progs/flame2.mdl" }) = light_flame_small_white :
"Small white flame" []

@PointClass size(-4 -4 -12, 4 4 20) base(Light, LightTarget, Targetname) model({ "path": ":progs/flame.mdl" }) = light_torch_small_walltorch :
"Small walltorch" []



@PointClass base(Appearflags, Targetname, LightTarget, Light) size(-8 -8 -8, 8 8 24) model({"path":"progs/fixture1.mdl"})= light_fixture1 :
"Wall-mounted light fixture."
[
	angle2(string) : "Angle" : : "The angle the model should be facing; set it to face away from the wall"
]


@PointClass base(Appearflags, Targetname, LightTarget, Light) size(-8 -8 -36, 8 8 8) model({"path": "progs/beacon.mdl"}) = light_beacon :
"Floor-mounted flashing red beacon
Set spawnflag 'Blinking' if you want the beacon to blink (set style to 16 to match the skin animation.)"
[
	angle2(string) : "Angle" : : "The angle the model should be facing; set it to face away from the wall"
	style(choices) : "Appearance" : 0 =
	[
		0 : "Normal"
		10: "Fluorescent flicker"
		2 : "Slow, strong pulse"
		11: "Slow pulse, noblack"
		5 : "Gentle pulse"
		1 : "Flicker A"
		6 : "Flicker B"
		3 : "Candle A"
		7 : "Candle B"
		8 : "Candle C"
		4 : "Fast strobe"
		9 : "Slow strobe"
		16 : "Match blinking animation"
	]
	spawnflags(flags) =
	[
		1 : "Blinking (also set style 16)" : 0
	]
]

//
// misc
//

@PointClass base(Appearflags, Targetname) = air_bubbles : "Air bubbles" []
@PointClass base(Appearflags, Targetname) = event_lightning : "Chthon's lightning" []

@PointClass size(0 0 0, 32 32 64) model({"path":"maps/b_explob.bsp"}) = misc_explobox : "Large nuclear container" []
@PointClass size(0 0 0, 32 32 32) model({"path":"maps/b_exbox2.bsp"}) = misc_explobox2 : "Small nuclear container" []

//@PointClass = func_illusionary2 : "Static model"  
//[
//	frame(integer)
//	model(string)
//]

@PointClass base(Targetname) color(220 150 150) = trap_spikeshooter : "Triggered shooter" 
[	
	angle(integer) : "Angle"
	spawnflags(Flags) = 
	[
		1 : "Superspike" : 0
		2 : "Laser" : 0
	]
]

@PointClass base(trap_spikeshooter) color(220 150 150) = trap_shooter : "Continuous shooter" [
	wait(float) : "time between spikes (1.0 default)" : "1.0"
	nextthink(integer) : "delay before firing first spike, so multiple shooters can be stagered"
]

@PointClass base(Appearflags) color(0 128 204) = misc_fireball : "Small fireball"
	[ speed(integer) : "Speed" : 40 ]

@PointClass base(Appearflags, Targetname, Target) color(0 128 204) = misc_sparks :
"Produces a burst of yellow sparks at random intervals. If targeted, it will toggle between on or off.  If it targets a light, that light will flash allong with each burst of sparks. 
Note: targeted lights should be set to START_OFF."
[
	wait(float) : "Delay between sparks" : "2.0" : "Average delay between bursts (variance is 1/2 wait)."
	cnt(integer) : "Amount of sparks" : 15 : "Average number of sparks in a burst (variance is 1/4 cnt)."
	sounds(choices) : "Sounds" =
	[
		0 : "No sound"
		1 : "Spark sounds"
	]
	spawnflags(flags) =
	[
		1 : "Starts off" : 0
		2 : "Blue sparks" : 0
		4 : "Pale yellow sparks" : 0
	]
]

@PointClass base(Appearflags, Targetname, Target) color(0 128 204) = misc_smoke :
"Produces a jet of smoke/steam. If targeted, it will toggle between on or off."
[
	wait(float) : "Time between puffs" : "1.0"
	movedir(string) : "Initial velocity" : "0 0 250" : "A vector representing the initial velocity in X Y Z values. Default is '0 0 250' (up)"
	movedir2(string) : "Wind direction" : "0 0 0" : "a vector representing the wind in X Y Z values.  Default is '0 0 0'"
	dmg(integer) : "Damage" : 0 : "Amount of damage each puff gives on contact."
	sounds(choices) : "Sounds" =
	[
		0 : "No sounds"
		1 : "Steam hiss"
	]
	spawnflags(flags) =
	[
		1 : "Starts off" : 0
	]
]

@PointClass base(Appearflags, Targetname, Target) color(0 128 204) = misc_splash :
"Produces a continuous particle splash for waterfalls."
[
	color(integer) : "Color (0-15)" : 0 : "Color of particles.  0 through 15, corresponds to a row of the quake palette. (default 0)"
	movedir(string) : "Move vector (X Y Z)"
	wait(float) : "Time between cycles" : "0.1"
	volume(integer) : "Density" : 10
]

@PointClass base(Appearflags, Targetname, Target)  color(0 128 204) model(
	{"path":"progs/flag.mdl", "frame": spawnflags & 2}
) = misc_flag :
"A hanging banner, gently waving in the wind. Normal dimensions: 64 wide by 144 long.
Big banner is twice as big: 128 wide by 288 long."
[	
	spawnflags(flags) =
	[
		1 : "Not animated" : 0
		2 : "Big one" : 0
	]
]


@PointClass base(Appearflags, Targetname) size(32 32 32) color(180 0 50) = target_meat_fireworks : "trigger for meat"
[
	count(integer) : "Repeat meat" : 1
	delay(string) : "Delay before first meat" : "0"
	wait(string) : "Wait between meat" : "1"
	rand(string) : "Random extra wait before meat" : "0"
	speed(integer) : "Speed of meat" : 128
	mangle(string) : "Override meat vector" : "0 0 1"
]

@PointClass base(Appearflags, Target, Targetname) size(32 32 16) color(255 128 0) studio({ "path" : mdl, "skin" : skin, "frame" : frame}) = misc_model :
"A point entity for displaying models. A frame range can be given to animate the model.

mdl: The model to display. Can be of type mdl, bsp, or spr.
frame: Single frame to display. Can also be used to offset the animation.
first_frame: The starting frame of the animation.
last_frame: The last frame of the animation.
speed: The frames per second of animation. Divide 1 by the fps for this value.
angles: pitch roll yaw (up/down, angle, tilt left/right)
NOTE: set angle value to 0 if using angles key to rotate mdls"
[
	angle(integer) : "Direction"
	skin(integer) : "Skin index (default 0)" : : "Skin index (default 0) Use this when your custom model has more than one skin to select"
	mdl(string) : "Model Selection (ex progs/model.mdl)"
	frame(integer)
	first_frame(integer)
	last_frame(integer)
	speed(integer) : "Speed" : 10
	angles(integer) : "set 'angle' to 0 if this is used"
	mdlsz(string) : "Entity size (x y z)"
	centeroffset(string) : "Model center offset (x y z)"
	spawnflags(flags) =
		[
			1: "Gravity" : 0
			2: "Solid" : 0
		]
]


@Pointclass base(Targetname, Appearflags) color(0 128 224) size(16 16 16) = target_screenshake : 
"Shakes the screen. Jostles the view of all clients, but doesn't physically move their bounding boxes or apply velocities.
Total shake duration is length + delay + wait." 
[
	length(string) : "Duration of full intensity (sustain)"
	delay(string) : "Time to ramp up from 0 (attack)"
	wait(string) : "Time to ramp down quake intensity to 0."
	strength(string) : "Intensity of quake. 1 is a hearty rumble, 10 is spasmodic bordering on hilarious." : "1.0"
	distance(integer) : "Attenuation distance; 0 is global" : 0
]

@PointClass = viewthing :
"A model will be spawned at the position of this entity. (default = player)

Just for debugging. Don't use.

Use the console commands 'viewmodel', 'viewframe', 'viewnext', 'viewprev' to view frames of model."
[]

@Pointclass base(Targetname, Appearflags, Deathtype) color(0 128 224) size(16 16 16) = target_explosion : 
"Causes explosions, same appearance as a rocket/grenade blast." 
[
	count(integer) : "Repeat count" : 1
	delay(string) : "Delay before first blast" : "0"
	wait(string) : "Wait between blasts" : "1"
	rand(string) : "Random extra wait before blasts" : "0"
	dmg(integer) : "Splash damage" : 0
]

@Pointclass base(Targetname, Appearflags) color(0 128 224) size(16 16 16) = target_telefog : 
"Causes a flash of teleport fog." 
[
	count(integer) : "Repeat count" : 1
	delay(string) : "Delay before first flash" : "0"
	wait(string) : "Wait between flashes" : "1"
	rand(string) : "Random extra before flashes" : "0"
]


@Solidclass base(Targetname, Appearflags) = misc_particlefield : 
"Makes dots appear continuously within its bounds. Trigger to toggle on/off.

Color Reference:
0-15 grey (higher = lighter)
16-31 dirt brown (higher = lighter)
32-47 sky blue (higher = lighter)
48-63 grass green (higher = lighter)
64-79 red (higher = lighter)
80-95 green/orange (higher = lighter)
96-111 copper/gold (higher = lighter)
112-127 flesh tone (higher = lighter)
128-143 pale purple (higher = darker)
144-159 reddish purple (higher = darker)
160-175 pale beige (higher = darker)
176-191 turquoise (higher = darker)
192-207 yellow (higher = darker)
208-223 deep blue (higher = darker)
224-239 fire/lava (higher = lighter)
240-255 fullbright mess" [
	spawnflags(flags) = [
		1 : "Start on" : 0
		2 : "Particles are sucked inward" : 0
		4 : "Particles are blown outward" : 0
		8 : "Oneshot burst when triggered" : 0
	]
	speed(integer) : "Clumps per second" : 10
	speed2(integer) : "Dots per clump" : 16
	health(integer) : "Color index (0-255)" : 0
	movedir(string) : "Velocity of particles (x y z)"
	wait(string) : "Interval" : 0.1
	velocity(string) : "Direction of optional sweep effect (x y z)"
]



@SolidClass base(Appearflags, Targetname) = misc_forcefield : "Creates a force field particle effect roughly the size of the defining brush. Can be toggled on/off by targeting it.

FORCEFIELD_START_ON Force field will spawn in the active state.

FORCEFIELD_PULSE Instead of a constant effect, the entity will generate a single pulse of the field effect each time it's triggered.

FORCEFIELD_SOLID Blocks movement when the field is active.

color is the color of the particles.  Default is 192 (yellow).
count is the density of the particles.  Default is 2.
noise is the sound to play when triggered.  Do not use a looping sound here.
dmg is the amount of damage to cause when touched."
[
	color(integer) : "Palette index for color" : 192
	count(integer) : "Density of particles" : 2
	dmg(integer) : "Amount of damage when touched" : 0
	spawnflags(flags) =
	[
		1 : "FORCEFIELD_START_ON" : 0
		2 : "FORCEFIELD_PULSE" : 0
		4 : "FORCEFIELD_SOLID" : 0
	]
]

@Pointclass base(Target, Targetname, Appearflags) color(255 0 128) size(32 32 32) = target_autosave : 
"Saves the game when triggered by a player. Never appears in multiplayer. 
the bprint tends to stomp any other prints on screen in most quake clients, so use a delayed trigger_relay if you fire this from an important pickup/trigger_counter/something else that puts text on screen more important than the autosave blurb." 
[
	message(string) : "Change save filename" : "auto"
]

// 
// ambient sounds
// added Rubicon 2 ambient_general
//

@PointClass color(64 32 192) = ambient_general : "Ambient sounds"
[
	noise(string) : "File to play"
	volume(float) : "Volume (0-1)" : "0.5"
	speed(integer) : "Attenuation" : 3
]
@PointClass color(64 32 192) = ambient_drip : "Dripping sound" []
@PointClass color(64 32 192) = ambient_drone : "Engine/machinery sound" []
@PointClass color(64 32 192) = ambient_comp_hum : "Computer background sounds" []
@PointClass color(64 32 192) = ambient_flouro_buzz : "Fluorescent buzzing sound" []
@PointClass color(64 32 192) = ambient_light_buzz : "Buzzing sound from light" []
@PointClass color(64 32 192) = ambient_suck_wind : "Wind sound" []
@PointClass color(64 32 192) = ambient_swamp1 : "Frogs croaking" []
@PointClass color(64 32 192) = ambient_swamp2 : "Frogs croaking B" []
@PointClass color(64 32 192) = ambient_thunder : "Thunder sound" []



@PointClass base(Targetname, Appearflags) size (16 16 24) color(30 150 35) = play_sound : "Hipnotic sound player

Plays a one off sound on a periodic basis.
Do NOT use looped sounds with this entity. For looped sounds use ambient_general.
volume: how loud (range is 0.1 to 1 default is 1 = full volume)
noise: path of sound to play
wait: random time between sounds (default 20)
delay: minimum delay between sounds (default 2)
impulse: sound channel 0-7 (0 automatic is default)
speed: attenuation factor

NOTE - Sound files must be in the SOUND folder (or a sub folder under the SOUND folder.)"
	[

		noise(string) : "Sound file to play"
		speed(choices) : "Attenuation of sound" : 1 =
				[
			-1 : "No attenuation (heard everywhere)"
			1  : "Normal"
			2  : "Idle"
			3  : "Static"
		]
		volume(integer) : "Volume (0 - 1)" : 1
		impulse(integer) : "Channel (0 - 7) Automatic" : 0
		wait(integer) : "Random time between sounds" : 20
		delay(integer) : "Minimum time between sounds" : 2
	]
@PointClass base(Targetname, Appearflags) size (16 16 24) color(30 200 35) = play_sound_triggered : "Custom sound trigger

toggle (spawnflags): stopped when triggered again
volume: how loud (range is 0.1 to 1 default is 1 = full volume)
noise: path of sound to play
impulse: sound channel 0-7 (0 automatic is default)
speed: attenuation factor

NOTE - Sound files must be in the SOUND folder (or a sub folder under the SOUND folder.)"
	[
		spawnflags(flags) = [1 : "Toggle" : 0]
		noise(string) : "Sound file to play"
		speed(choices) : "Attenuation of sound" : 1 =
		[
			-1 : "No attenuation (heard everywhere)"
			1  : "Normal"
			2  : "Idle"
			3  : "Static"
		]
		volume(integer) : "Volume (0 - 1)" : 1
		impulse(integer) : "Channel (0 - 7) Automatic" : 0
		//wait(integer) : "Wait before retrigger" : 0 //Quoth2
	]





// 
// moving things
//


@SolidClass base(Angle, Appearflags, Targetname, Target, ModelLight) = func_door : "Basic door" 
[
	speed(integer) : "Speed" : 100
	sounds(choices) : "Sound" : 0 = 
	[
        0: "No sounds"
		1: "Stone"
		2: "Machine"
		3: "Stone Chain"
		4: "Screechy Metal"
		5: "Custom sounds"
	]
	noise1(string) : "Sound file for the 'stop moving' sound (if set, overrides 'sounds')"
	noise2(string) : "Sound file for the 'move' sound (if set, overrides 'sounds')"
	noise3(string) : "Sound file for the 'key required' sound (default is per worldtype)"
	noise4(string) : "Sound file for the 'key used' sound (default is per worldtype)"
	cnt(choices) : "Leave key in player's inventory?" : 0 =
	[
		0 : "Don't leave key in player's inventory"
		1 : "Leave key in player's inventory"
	]
	keyname(string) : "If set, this is the keyname of the item_key_custom which unlocks this entity"
	wait(float) : "Delay before close" : "3.0"
	lip(integer) : "Lip" : 8
	dmg(integer) : "Damage inflicted when blocked" : 0
	message(string) : "Message if triggered"
	health(integer) : "Health (shoot open)" : 0
	spawnflags(flags) =
	[
		1 : "Starts Open" : 0
		4 : "Don't link" : 0
		8 : "Gold Key required" : 0
        16: "Silver Key required" : 0
        32: "Toggle" : 0
	]
]

@SolidClass base(Angle, Appearflags, Targetname, Target, ModelLight) = func_door_secret : "Triggered door" 
[
	t_width(integer) : "First move lenght"
	t_length(integer) : "Second move lenght"
	dmg(integer) : "Damage when blocked" : 2
	wait(float) : "Time before close" : "2.0"
	sounds(choices) : "Sounds" : 3 =
	[
		1: "Medieval"
		2: "Metal"
		3: "Base"
	]
	message(string) : "Message"
	spawnflags(flags) = 
	[
		1 : "Open once only" : 0
		2 : "Moves left first" : 0
		4 : "Moves down first" : 0
		8 : "Not shootable" : 0
        16 : "Always shootable" : 0
	]
]

@SolidClass base(Targetname, Appearflags, ModelLight, Alpha) = func_wall : "Wall" []


@SolidClass base(Appearflags, Targetname) = func_togglewall : "Creates a invisible wall that can be toggled on and off.

START_OFF wall doesn't block until triggered.

noise is the sound to play when wall is turned off.
noise1 is the sound to play when wall is blocking.
dmg is the amount of damage to cause when touched."
[
	noise(string) : "Power off sound"
	noise1(string) : "Sound when touched"
	dmg(integer) : "Amount of damage when touched" : 0
	spawnflags(flags) =
	[
		1 : "Start Off" : 0
	]
]

@SolidClass base(ModelLight, Alpha) = func_illusionary : "Static model" []

@SolidClass base(Angle, Targetname, Target, ModelLight) = func_button : "When a button is touched, it moves some distance in the direction of it's angle, triggers all of it's targets, waits some time, then returns to it's original position where it can be triggered again." 
[
	speed(integer) : "Speed (units per second)" : 40
	lip(integer) : "Lip" : 4
	health(integer) : "Health (shootable if > 0)"
	sounds(choices) : "Sounds" = 
	[
		0 : "Steam metal"
		1 : "Wooden clunk"
		2 : "Metallic clink"
		3 : "In-out"
	]
	wait(float) : "Delay before reset" : "1.0"
	delay(string) : "Delay before trigger"
	message(string) : "Message" 
]

@SolidClass base(Targetname, ModelLight) = func_train :
"Trains are moving platforms that players can ride. The target's origin specifies the min point of the train at each corner. The train spawns at the first target it is pointing at.

Use path_corner as targets.
To stop a train entity, make the the last path_corner Wait -1.
If the train itself is the target of a button or trigger, it will not begin moving until activated.

Flags:
RETRIGGER: stop at each path_corner and don't resume until triggered again (ignores wait time)
" 
[
	sounds(choices) : "Sound" : 1 =
	[
		0: "None"
		1: "Ratchet Metal"
	]
	speed(integer) : "Speed (units per second)" : 100
	target(target_source) : "First stop target"
	dmg(integer) : "Damage on crush" : 2
	spawnflags(flags) =
	[
		1: "Retrigger" : 0
	]
]

@PointClass base(Targetname) color(128 64 0) size(8 8 8) = path_corner :
"Moving platform stop"
[
	target(target_source) : "Next stop target"
	wait(float) : "Wait" : "0"
]

@SolidClass base(Targetname, ModelLight) = func_plat :
"Plats are always drawn in the extended position, so they will light correctly.

If the plat is the target of another trigger or button, it will start out disabled in the extended position until it is triggered, when it will lower and become a normal plat.

Flags:
low_trigger: plat will only be triggered when in lowered position" 
[	
	spawnflags(Flags) =
	[
		1 : "Low trigger" : 0
	]
	speed(integer) : "Speed" : 150
	height(integer) : "Travel altitude (can be negative)" : 0
	sounds(choices) : "Sound group" : 1 =
	[
		0: "None"
		1: "Base fast"
		2: "Chain Slow"
	]
]	

@SolidClass = func_episodegate : "Episode Gate"
[
	spawnflags(Flags) =
	[
		1 : "Episode 1" : 1
		2 : "Episode 2" : 0
		4 : "Episode 3" : 0
		8 : "Episode 4" : 0
	]
]

@SolidClass = func_bossgate : "Boss gate" []


@SolidClass color(128 128 230) base(ModelLight) = func_detail : "Detail brush. Ignored by vis so can speed up compile times consideratbly. Also allows you to set new compiler lighting options on brushes. DOES NOT SEAL MAPS FROM VOID" []

@SolidClass color(128 128 230) base(ModelLight) = func_detail_illusionary : "func_detail variant with no collision (players / monsters / gunfire) and doesn't split world faces. Doesn't cast shadows unless enabled with _shadow 1. Useful for hanging vines. Still creates BSP leafs." []

@SolidClass color(128 128 230) base(ModelLight) = func_detail_wall : "func_detail variant that doesn't split world faces. Useful for when you want a decoration touching a floor or wall to not split the floor - wall faces (you'll get some overdraw instead.) If it completely covers up a world face, that face will get clipped away, so it's not suitable for fence textures; see func_detail_fence instead" []

@SolidClass color(128 128 230) base(ModelLight) = func_detail_fence : "Similar to func_detail_wall except it's suitable for fence textures, never clips away world faces. Useful for fences, grates, etc., that are solid and block gunfire" []

@SolidClass base(ModelLight) = func_group : "Brush group. Is treated by qbsp as world brushes but allows you to add light shading settings. _dirt and _shadow currently only accept -1 as a valid setting for func_group" []


@SolidClass base(Appearflags, Targetname) = func_bob : "A SOLID bmodel that gently moves back and forth."
[
	angle(integer) : "direction movement, use 360 for angle 0" : 0
	height(integer) : "direction intensity" : 8
	count(integer) : "direction cycle timer minimum = 1" : 2
	waitmin(integer) : "Speed up scale default = 1, 1+ =non linear" : 1
	waitmin2(integer) : "Slow down scale default = 0.75"
	delay(integer) : "Starting time delay defualt = 0, -1 = random"
	style(integer) : "If set to 1, starts off and waits for trigger"
	_dirt(integer) : "-1 = will be excluded from dirtmapping"
	_minlight(integer) : "Minimum light level for any surface of the brush model"
	_mincolor(integer) : "Minimum light color for any surface (default = '1 1 1' RGB)"
	_shadow(integer) : "Will cast shadows on other models and itself"
	_shadowself(integer) : "Will cast shadows on itself"

	spawnflags(flags) =
	[
		2 : "BOB_COLLISION" : 2
		4 : "BOB_NONSOLID" : 0
	]
]

@PointClass base(Appearflags, Targetname) size(16 16 16) color(255 128 0) studio({ "path" : mdl, "skin" : skin, "frame" : frame}) = misc_bob : "A model that gently moves back and forth."
[
	angle(integer) : "direction movement, use 360 for angle 0" : 0
	height(integer) : "direction intensity" : 8
	count(integer) : "direction cycle timer minimum = 1" : 2
	waitmin(integer) : "Speed up scale default = 1, 1+ =non linear" : 1
	waitmin2(integer) : "Slow down scale default = 0.75"
	delay(integer) : "Starting time delay defualt = 0, -1 = random"
	style(integer) : "If set to 1, starts off and waits for trigger"
	mdl(string) : "Path to mdl file"
	spawnflags(flags) =
	[
		2 : "BOB_COLLISION (default)" : 2
		4 : "BOB_NONSOLID" : 0
	]
]



//
// triggers
//

@BaseClass color(128 0 128) base(Target, Targetname) = Trigger
[
	sounds(choices) : "Sound style" : 0 =
	[
		0 : "None"
		1 : "Secret sound"
		2 : "Beep beep"
		3 : "Large switch"
		4 : "Set message to text string"
	]
	delay(string) : "Delay before trigger" : "0"
	message(string) : "Message (set sound too!)"
]

@BaseClass = TriggerWait [
	is_waiting(choices) : "Dormant Trigger" : 0 :
	"If set to 1, the trigger starts dormant and waits for activation. Subsequent activations trigger its target as usual." =
	[
		0 : "Default"
		1 : "Wait for Trigger"
	]
]

@SolidClass = trigger_changelevel : "Trigger: Change level"
[
	map(string) : "New map name"
	target(target_destination) : "Target"
	spawnflags(flags) =
	[
		1: "No Intermission" : 0
	]
]

@SolidClass base(Trigger, TriggerWait) = trigger_once : "Trigger: Activate once"
[
	health(integer) : "Health"
	spawnflags(flags) = [ 1: "Entity only" : 0 ]
]
@SolidClass base(Trigger, TriggerWait) = trigger_multiple : "Trigger: Activate multiple" 
[
	wait(float) : "Wait before reset" : "4"
	health(integer) : "Health"
	spawnflags(flags) = [ 1: "Entity only" : 0 ]
]
@SolidClass base(Trigger) = trigger_onlyregistered : "Trigger: Registered only" 
[
	spawnflags(flags) = [ 1: "Entity only" : 0 ]
]
@SolidClass base(Trigger, TriggerWait) = trigger_secret : "Trigger: Secret" 
[
	sounds(choices) : "Sound style" : 1 =
	[
		0 : "None"
		1 : "Secret sound"
		2 : "Beep beep"
		3 : "Large switch"
		4 : "Set message to text string"
	]
	spawnflags(flags) = [ 1: "Entity only" : 0 ]
]

@SolidClass base(Target, Targetname) = trigger_teleport : "Trigger teleport" 
[
	spawnflags(Flags) =
	[
		1 : "Player only" : 0
		2 : "Silent" : 0
	]
]

@SolidClass base(Appearflags) = trigger_void : "Use this for a 'void' area. Removes monsters, gibs, ammo, etc... also kills player"
[
	spawnflags(Flags) =
	[
		1 : "No Effect on Monsters" : 0
		2 : "No Effect on Players" : 0
	]
]

// need updates:

@SolidClass = trigger_setskill : "Trigger set skill" 
[
	message(choices) : "Skill to change to" : 1 =
	[
        0 : "Easy"
        1 : "Medium"
        2 : "Hard"
        3 : "Nightmare!"
	]
]
@PointClass base(Trigger) = trigger_relay : "Trigger relay"
[
]
@SolidClass base(Targetname) = trigger_monsterjump : "Trigger monster jump" 
[
	speed(integer) : "Jump Speed" : 200
	height(integer) : "Jump Height" : 200
	angle(integer) : "Angle"
]
@PointClass base(Trigger, Target, Targetname) = trigger_counter : "Trigger counter" 
[
	spawnflags(flags) = [ 1: "No Message" : 0 ]
	count(integer) : "Count before activation" : 2
]
@SolidClass base(Targetname) = trigger_push : "Trigger player push"
[
	angle(integer) : "Angle"
	spawnflags(flags) = [ 1: "Once Only" : 0 ]
	speed(integer) : "Speed of push" : 1000
]
@SolidClass  base(Targetname) = trigger_hurt : "Trigger player hurt" 
[
	dmg(integer) : "Damage" : 5
	wait(float) : "Delay before reset"
	message(string) : "Message"
]



@SolidClass base(Appearflags, Targetname, Target, FogShift) = trigger_fogblend : 
"Trigger: Fog Blend
Acts as a smoothly blending portal between two zones of different fog. Sets the fog for any client passing through it, blending their global fog settings between start and end values proportional to their position within the trigger.

- will 'stuffcmd' 2 dozen times per frame so try not to make these huge
- a bug in most quake engine ports will reset the eye position smoothing that happens when climbing stairs or riding a plat on every frame that a 'stuffcmd' is sent, so fog transitions during upwards motion will cause noticeable stuttering." 
[
	distance(integer) : "Length of blend distance (defaults to size of trigger)"
	angle(integer) : "Axis of motion of blend (points toward end values)"
]


@PointClass base(Appearflags, Targetname, Target, FogShift) color(128 128 50) = target_fogblend : 
"Target: Fog Blend
Activator's fog will be blended over time from start to end values.

- will 'stuffcmd' 2 dozen times per frame so try not to make this take too long
- a bug in most quake engine ports will reset the eye position smoothing that happens when climbing stairs or riding a plat on every frame that a 'stuffcmd' is sent, so fog transitions during upwards motion will cause noticeable stuttering." 
[
	spawnflags(flags) = [
		1 : "One-Way Only" : 0
		2 : "Reverse Start/End" : 0
		4 : "All clients" : 0
	]
	delay(string) : "Pause before starting blend"
	speed(string) : "Time to blend (-1 for instant)"
	speed2(string) : "Time to blend back, if different (-1 for instant)"
]


@SolidClass base(Appearflags) = trigger_setgravity : "Trigger: sets the gravity of a player or monsters

gravity = what to set the players gravity to

If using multiple triggers, do not have them touching. Leave a 'buffer' between them.

 - 0 (default) normal gravity
 - 1 no gravity
 - 2 almost no gravity
 - 15 floaty
 - ...
 - 101 normal gravity
 - 102 slightly higher gravity
 - ...
 - 1000 very high gravity
"
[
	spawnflags(flags) = [
		8: "Start Off (can be toggled)" : 0
		16: "Player only" : 0
	]
	gravity(integer) : "Gravity : Normal = 0" : 0
]


//dumptruck_ds added from Hipnotic Mission Pack
@SolidClass base(Appearflags, Target, Targetname) = trigger_usekey :
"Trigger: Requires a Key

NOTE: You must specify either the silver or gold key by setting the relevant spawnflag, or specify an item_key_custom by setting the 'keyname' value so that it matches the 'keyname' value of the item_key_custom."
[
	cnt(choices) : "Leave key in player's inventory?" : 0 =
	[
		0 : "Don't leave key in player's inventory"
		1 : "Leave key in player's inventory"
	]
	delay(float) : "Delay before trigger" : "0" : "Delay before trigger"
	keyname(string) : "If set, this is the keyname of the item_key_custom which unlocks this entity"
	message(string) : "Custom message"
	noise1(string) : "Sound file for the 'key required' sound (default is per worldtype)"
	noise2(string) : "Sound file for the 'key used' sound (default is per worldtype)"
	spawnflags(flags) =
	[
		8 : "Silver Key Required" : 0
		16 : "Gold Key Required" : 0
	]
]