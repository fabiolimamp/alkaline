<!DOCTYPE html>
<html>
<meta charset="utf-8">
<title>Alkaline</title>
<style>
body {
	font-family: 'Helvetica', 'Arial', sans-serif;
	font-size: 1rem;
}
</style>
<head>
</head>

<body>

<h1>Alkaline Mapping Guide</h1>
<h2>Contents</h2>
<nav>
<ul>
	<li><a href="#philosophy">Philosophy</a></li>

	<li>
		<a href="#monsters">Monsters</a>
		<ul>
			<li><a href="#monster-triggered-spawning">Triggered spawning</a></li>
			<li><a href="#monster-spawner">Monster spawner</a></li>
			<li><a href="#path-angry">Angry monsters' waypoints</a></li>
			<li><a href="#monster-other-features">Other features</a></li>
			<li><a href="#target_infight">Entity target_infight</a></li>
			<li><a href="#monsters-list">Monsters list</a></li>
			<li><a href="#scientists">Scientists</a></li>
		</ul>
	</li>

	<li>
		<a href="#items">Items</a>
		<ul>
			<li><a href="#circuitboard">Circuitboard</a></li>
			<li><a href="#trifecta">Trifecta</a></li>
			<li><a href="#boots">Jump Boots</a></li>
			<li><a href="#shards">Armor Shards</a></li>
			<li><a href="#keys">Keys</a></li>
			<li><a href="#item-respawning">Item respawning</a></li>
			<li><a href="#item-trigger-spawning">Trigger spawning</a></li>
			<li><a href="#item-positioning">Item positioning</a></li>
			<li><a href="#item-style">Item box model style</a></li>
		</ul>

	</li>
	<li>
		<a href="#weapons">Weapons</a>
		<ul>
			<li><a href="#new-weapons">New weapons</a></li>
			<li><a href="#custom-loadout">Custom loadout</a></li>
			<li><a href="#axe-shotgun">Axe and shotgun pickups</a></li>
			<li><a href="#target_removeitems">target_removeitems entity</a></li>
			<li><a href="#particle-impact">Custom impact particle effect</a></li>
		</ul>
	</li>
	<li>
		<a href="#triggers">Triggers</a>
		<ul>
			<li><a href="#multiple-targets">Multiple targets</a></li>
			<li><a href="#dormant-triggers">Dormant triggers</a></li>
			<li><a href="#monster-triggerable">Monster-activated triggers</a></li>
			<li><a href="#message-all">Message all players</a></li>
			<li><a href="#trigger_repeat">Repeater/timer trigger</a></li>
			<li><a href="#monsterjumps">Monsterjumps</a></li>
			<li><a href="#hurt">Hurt triggers</a></li>
			<li><a href="#stealth-teleport">Stealth teleport</a></li>
			<li><a href="#multiple-destinations">Multiple teleport destinations</a></li>
			<li><a href="#mapvars">Mapvars</a></li>
			<li><a href="#mapstart">Multiple map starting spots</a></li>
		</ul>
	</li>
	<li>
		<a href="#doors">Doors</a>
		<ul>
			<li><a href="#door-distance-angle">Distance and angle</a></li>
			<li><a href="#door-delay">Delayed movement</a></li>
			<li><a href="#door-linking">Door grouping/linking</a></li>
			<li><a href="#door-sounds">Sounds</a></li>
			<li><a href="#door-keys">Keys</a></li>
			<li><a href="#door-set-position">Setting a door position directly</a></li>
			<li><a href="#door-trigger-field">Trigger field</a></li>
		</ul>
	</li>

	<li>
		<a href="#plats">Plats</a>
		<ul>
			<li><a href="#plat-start-at-top">Plat start at top</a></li>
			<li><a href="#plat-toggle">Plat Toggle</a></li>
			<li><a href="#plat-elevator">Elevator</a></li>
			<li><a href="#plat2">Plat2</a></li>
			<li><a href="#other-plat-features">Other new features</a></li>
		</ul>
	</li>

	<li><a href="#trains">Trains</a>
		<ul>
			<li><a href="#modeltrain">Model trains</a></li>
		</ul>
	</li>

	<li>
		<a href="#state-system">State System</a>
		<ul>
			<li><a href="#state-triggers">Trigger brushes of any class</a></li>
			<li><a href="#state-doors">Doors</a></li>
			<li><a href="#state-buttons">Buttons</a></li>
		</ul>
	</li>

	
	<li>
		<a href="#advanced-triggering">Advanced triggering</a>
		<ul>
			<li><a href="#trigger_filter">trigger_filter</a></li>
			<li><a href="#trigger_everything">trigger_everything</a></li>
			<li><a href="#target_setcount">target_setcount</a></li>
		</ul>
	</li>
	
	<li>
		<a href="#shadows">Shadows</a>
		<ul>
			<li><a href="#func_shadow">func_shadow entity</a></li>
			<li><a href="#switchable-shadows">Switchable shadows</a></li>
		</ul>
	</li>

	<li>
		<a href="#lights">Lights</a>
		<ul>
			<li><a href="#enhanced-light-toggling">Enhanced Toggling</a></li>
			<li><a href="#target_lightstyle">Setting a light's style directly</a></li>
			<li><a href="#new-light-fixtures">New light fixtures</a></li>
		</ul>
	</li>
	<li>
		<a href="#fog">Fog</a>
		<ul>
			<li><a href="#trigger_fogblend">Blending fog between two areas</a></li>
			<li><a href="#target_fogblend">Time-based fog blending</a></li>
			<li><a href="#skyfog">Sky fog</a></li>
		</ul>
	</li>
	<li>
		<a href="#solids">Solids</a>
		<ul>
			<li><a href="#breakables">Breakables</a></li>
			<li><a href="#togglable-brushes">Walls and togglable brushes</a></li>
			<li><a href="#misc_model">misc_model</a></li>
			<li><a href="#rotators">Rotators</a></li>
			<li><a href="#exploboxes">Exploboxes</a></li>
			<li><a href="#laser">Laser</a></li>
			<li><a href="#ladders">Ladders</a></li>
			<li><a href="#bobbing">Bobbing brushes</a></li>
		</ul>
	</li>

	<li>
		<a href="#sounds-music">Sounds and music</a>
		<ul>
			<li><a href="#triggered-sounds">Triggered sounds</a></li>
			<li><a href="#ambient-sounds">Ambient sounds</a></li>
			<li><a href="#music">Music</a></li>
		</ul>
	</li>

	<li>
		<a href="#environmental-effects">Environmental Effects</a>
		<ul>
			<li><a href="#void">Void</a></li>
			<li><a href="#gravity">Gravity</a></li>
			<li><a href="#explosions">Explosions</a></li>
			<li><a href="#particle-field">Particle field</a></li>
			<li><a href="#lightning-trail">Lightning trail</a></li>
			<li><a href="#screen-shake">Screen shake</a></li>
			<li><a href="#text-story">Story texts</a></li>
			<li><a href="#other-effects">Other effects</a></li>

		</ul>
	</li>

	<li>
		<a href="#enhancements">Other Enhancements</a>
		<ul>
			<li><a href="#autosaves">Autosaves</a></li>
			<li><a href="#episode-ending">Episode-ending screen</a></li>
			<li><a href="#target_move">target_move</a></li>
			<li><a href="#developer">Developer features</a></li>
			<li><a href="#cheats">Cheats commands</a></li>
		</ul>
	</li>

	<li>
		<a href="#thanks">Thanks</a>
	</li>
</ul>
</nav>

<h2 id="philosophy">Philosophy</h2>

<p>
	Alkaline was originally built upon Rubicon 2 codebase. But over our development period, a great deal of code ended up being changed. Lots of new features, monsters, items, powerups, bug corrections... So it grew up into its own thing. We've borrowed ideas (or entire features altogether) from all the great mods and mod frameworks of our time. Copper, Arcane Dimensions, progs_dump, Zerstorer, Malice, Rubicon Rumble Pack, Quoth... you name it. Also we've got a bunch of exclusive features. Our main focus was on things that we felt would be nice to have in all kinds of base-themed maps.
</p>
<p>
	We've decided to not change anything gameplay-related. All original weapons, monsters and items behave almost exactly the way you've known and loved for the last 25 years. We think it's laudable what mods like Copper or AD have done to improve balance and gameplay, but our intention was to expand over the solid gameplay foundations that vanilla Quake laid, and add a load of new features and mapping quality-of-life enhancements on top of it.
</p>
<p>
	We'll do a more in-depth walkthrough into Alkaline's features, so any mapper can take it as a framework for their own map or mod. We've decided to go through everything that's been changed from vanilla instead of pure Rubicon 2, for an easier understanding.
</p>

<hr>

<h2 id="monsters">Monsters</h2>

<p>Monsters have a multitude of new features.</p>
<h3 id="monster-triggered-spawning">Triggered spawning</h3>
<p>By setting the <strong>Trigger Spawned</strong> spawnflag, the monster will only show up after it's been triggered. The following spawnflags can be used together with it:</p>

<ul>
<li><strong>Silent spawn</strong>: makes it spawn without making the teleport effect & sound, for when you need to repopulate an area out of the player's view.</li>
<li><strong>Spawn angry</strong>: spawns the monster already in alert state.</li>
<li><strong>Count after spawn</strong>: the monster adds to the map's total monster count only after it's been spawned in.</li>
</ul>

<h3 id="monster-spawner">Monster spawner</h3>
<p>
	Checking the <strong>Monster spawner</strong> flag turns this entity into a monster spawner, that creates a new instance of the monster whenever it's triggered. They always spawn angry, and have a telefrag check, so they may wait for a few seconds until they have room to spawn. The spawned monsters inherit all of the spawner entity's <strong>target*</strong> fields, so you can use it to add to a counter when they're killed for example.
	If you want it to spawn monsters in a defined time interval, you can set it up in conjunction with a <strong>trigger_repeat</strong>.
</p>
<p>The following keys are related to it:</p>

<ul><li><strong>totalspawncount</strong>: When set, the spawner will stop when it has spawned this amount of monsters. Also the total monster counter will start with this value already counted in, unless you set the <strong>Count after spawn</strong> flag as well. By default, it'll spawn monsters indefinitely.</li>
<li><strong>spawncount</strong>: Maximum amount of monsters spawned by this entity that can be alive at the same time (defaults to 10 monsters). If this value is reached, the monsters will stop spawning in from this entity until they're killed. Good for not overwhelming the player with a ludicrous amount of monsters in the same arena. Set to -1 if you want to disable this limit.</li>
</ul>

<h3 id="path-angry">Angry monsters' waypoints</h3>
<p>The <strong>path_angry</strong> point entity makes monsters follow a path automatically when angered for the first time, either by sight or trigger. They'll always follow the path up to its end, where they return to their normal movement behavior. While following this path, they can still see and attack you normally. It's useful when you need a monster to reliably come out of somewhere or run through complex pathways when angered, without randomly bumping into things while trying to get to you.</p>
<p>It works the same way as a path_corner, as in, you chain <strong>path_angry</strong> entities by their target/targetname fields to form a path, and make the monster target the first one - but it'll only act when the monster get angered or triggered.</p>
<p>Note that the chained <strong>path_angry</strong> entities must have an endpoint that doesn't target any other if you want the monster to get out of its path-chasing behavior. Also flying monsters don't work with it yet.</p>

<h3 id="monster-other-features">Other features</h3>
<ul><li><strong>No sight sound</strong> flag: The monster won't make its sight sound when angry at something.</li>
<li><strong>No infight</strong> flag: The monster won't be angry at another when hit, only at players. Note that it doesn't prevent some other monster from getting angry at it, thus never giving it a chance to fight back.</li>
<li><strong>No idle sounds</strong> flag: The monster won't make any idle sounds when standing still. It'll still make sounds if walking/following path_corners though.</li>
<li><strong>Above</strong> key (flying monsters only): Specifies a height in units that a the monster will try to stay above the player, instead of always hover at its height.</li>
</ul>

<h3 id="target_infight">Infight trigger</h3>
<p>Point entity that makes <strong>target</strong> monster angry at <strong>target2</strong> when triggered.</p>
<p>
By default, the infighting doesn't start mutually, that is, <strong>target2</strong> monster will only get mad back at <strong>target</strong> after it's been attacked. If you want to make them angry at each other instantly, you can set the spawnflag <strong>Mutual hate</strong>.
</p>

<h3 id="monsters-list">Monsters list</h3>
<p>Last, but not least, here's the list of the baddies that come with Alkaline. The other non-base vanilla monsters not mentioned here behave and look the same, and they're all still available to use.</p>

<p>All of the original monsters whose visuals/sounds were modified (Death Knight, Scrag, Ogre and Fiend), are also available in their original versions, selectable through the spawnflag <strong>Original version</strong>.</p>

<ul>
	<li><strong>Grunt (monster_army):</strong> 30 HP</li>
	<li><strong>Nail Grunt (monster_nailgrunt):</strong> 30 HP</li>
	<li><strong>Rottweiler (monster_dog):</strong> 25 HP</li>
	<li><strong>Spiderbot (monster_spiderbot):</strong> 40 HP</li>
	<li><strong>Enforcer (monster_enforcer):</strong> 80 HP</li>
	<li><strong>Ogre (monster_ogre):</strong> 200 HP</li>
	<li><strong>Ogre Marksman (monster_ogre_marksman):</strong> 200 HP</li>
	<li><strong>Berserker (monster_ogreb):</strong> 200 HP</li>
	<li><strong>Axe Grunt (monster_axegrunt):</strong> 75 HP</li>
	<li><strong>Sabre Knight (monster_hell_knight):</strong> 250 HP</li>
	<li><strong>Dreadnaught (monster_dreadnaught):</strong> 150 HP</li>
	<li><strong>Centroid (monster_scourge):</strong> 300 HP</li>
	<li><strong>Spiderbot (monster_spiderbot):</strong> 25 HP</li>
	<li><strong>Eel (monster_eel):</strong> 25 HP</li>
	<li><strong>Frogman (monster_frogman):</strong> 100 HP</li>
	<li><strong>Drone (monster_drone):</strong> 100 HP</li>
	<li><strong>Centurion (monster_centurion):</strong> 150 HP</li>
	<li><strong>Probe (monster_probe):</strong> 200 HP</li>
	<li><strong>Grenade Probe (monster_grenadeprobe):</strong> 200 HP</li>
	<li><strong>Floyd Automaton (monster_floyd):</strong> 200 HP</li>
	<li><strong>Mega Enforcer (monster_me):</strong> 150 HP</li>
	<li><strong>Mutant (monster_mutant):</strong> 220 HP</li>
	<li><strong>Fiend (monster_demon1):</strong> 300 HP</li>
	<li><strong>Edie (monster_edie):</strong> 500 HP</li>
	<li><strong>Bambler (monster_bambler):</strong> 500 HP</li>
	<li><strong>Hunter (monster_hunter):</strong> 600 HP</li>
	<li><strong>Arachnofloyd (monster_arachnofloyd):</strong> 600 HP</li>
	<li><strong>Lieutenant (monster_super_enforcer):</strong> 120 HP + 1000 armor</li>
	<li><strong>Prowler (monster_rider):</strong> 600-777 HP</li>
	<li><strong>Annihilator (monster_banshee):</strong> 1300 HP</li>
	<li><strong>Tormentor (monster_tormentor):</strong> 2000 HP</li>
	<li><strong>Ogregon (monster_armagon):</strong> 2000-3500 HP</li>
</ul>

<h3 id="scientists">Scientists</h3>
<p>Poor scientists that have nothing to do with the Ranger's struggles through eldridtch dimensions. They won't fight, just keep doing their jobs, or run aimlessly in panic. Select that behaviour through the spawnflag <strong>Ignore player</strong>.</p>
<p>Set <strong>wait</strong> and <strong>angle</strong> on path_corners for them to stop and work.</p>
<p>By default they won't count into total monster count, unless you set <strong>Count After Spawn</strong> flag.</p>

<h3 id="health-triggers">Health Triggers</h3>
<p>By activating the <strong>Health trigger</strong> spawnflag, the monster will fire <strong>target2</strong>, <strong>target3</strong> and <strong>target4</strong> when it takes 25%, 50% and 75% damage, respectively. Only <strong>target</strong> will be fired immediately when the monster dies in this case.</p>

<p>You don't have to assign targets to each health trigger level, just the ones you need. So, for example, you can ignore <strong>target2</strong> and <strong>target3</strong> if you only need a trigger to fire at 75% damage. Also, all assigned targets WILL fire when their thresholds have passed, even if they happen at the same frame - so if you gib or 1-hit-kill an enemy for example, all its remaining targets will be fired at the same time.</p>



<hr>

<h2 id="items">Items</h2>

<p>Alkaline has some new items and item features.</p>

<h3 id="circuitboard">Circuitboard</h3>
<p>Deployed through the point entity <strong>item_circuitboard</strong>, the circuitboard (or rather the "17-centimeter Fromitz board") is a completely customizable dummy item that does nothing on its own, nor adds anything to your inventory. It merely fires its targets when picked up. But don't be fooled by its simplicity, because it's where lies all its power. You can use it to trigger any event, say, spreading various circuitboards throughout your map, all targeting the same trigger_counter, that unlocks a door or a super secret for example. Almost every map in Alkaline used it in some way.</p>
<p>You can set a custom model (<strong>mdl</strong> key), pickup sound file (<strong>noise</strong> key), and pickup name (<strong>netname</strong> key). By default the pickup text will be shown at the top of the screen like any other item, but if you want to suppress that and just centerprint a message instead, you can set the <strong>No pickup text</strong> flag and define the message in the <strong>message</strong> field.
</p>

<h3 id="trifecta">Trifecta</h3>
<p>
	The new awesome powerup in Alkaline. Gives you quad-damage, invincibility, and a mega health boost, all in one.
</p>

<h3 id="boots">Jump Boots</h3>
<p>
	This well-known powerup is available as well. Comes in two versions:
</p>
<ul>
	<li><strong>Persistent (item_jboots):</strong> always-on and upgradeable indefinitely. Each time one is picked up by a player, they get another jump charge. Also it's not removed from the inventory after a map change.</li>
	<li><strong>Timed (item_jboots_timed):</strong> Timed upgrade, available for 30s. By default it gives limitless charges, but you can change that through the <strong>jboots_rechargelimit</strong> key.</li>
</ul>
	
<h3 id="shards">Armor Shards</h3>
<p>Gives 5 armor points. It adds up to the player's current armor if it has one, and can go up to 25 points more than the armor type's maximum points. So, up to 125 for green armor, 175 for yellow, and 225 for red. If the player doesn't have any armor, it'll always count as green.</p>


<h3 id="keys">Keys</h3>
<p>Alkaline borrows the custom key system from progs_dump. You can create a key using the <strong>item_key_custom</strong> entity, and define a custom model, skin, sound and name. Then on any door you can set the name of the key that will open it. For more details, please refer to the in-editor documentation.</p>

<p>Also from progs_dump comes the <strong>trigger_usekey</strong> brush entity. You can use it to "consume" a key from the player's inventory (custom or not) and trigger some event - like a door would, but with no need for a door. It can be used by a player touching it, or by triggering.</p>

<h3 id="item-respawning">Item respawning</h3>
<p>Setting an item's <strong>ritem</strong> key to 1 makes it respawns after a few seconds, customizable through the <strong>respawndelay</strong> key. You also can set the maximum number of respawns through <strong>respawncount</strong>.
</p>
<p>By default, the item makes the traditional teleport sound/fog effect when respawning, but you can change it to the more discreet deathmatch-style respawn effect, through the spawnflag <strong>Spawn with DM effects</strong>.
</p>

<h3 id="item-trigger-spawning">Trigger spawning</h3>
<p>Like monsters, items also support trigger-spawning. Just set the <strong>Trigger spawned</strong> flag and it'll only show up after triggered. You can make it spawn silently using the <strong>Spawn silent</strong> flag.
</p>

<h3 id="item-positioning">Item positioning</h3>
<p>The <strong>Suspended in air</strong> spawnflag makes the item stay in place and never drop to the floor, so it hovers in midair. Quoting Lunaran in a similar Copper feature:
	<blockquote>It's a useful hackaround for items that insist on falling out of the world and vanishing because they don't like where you placed them. This also provides a handy solution to the irritating problem that a monster and an item cannot overlap without pushing the item out of the world.
    Even if items don't fall out of the world when you test your map in your Quake engine port of choice, inconsistent droptofloor() results are not unheard of across ports. Consider it best practice to always mark as SUSPENDED any progression-critical items like keys, or any other item that fires a necessary targetname, even when placed on the ground.</blockquote>
</p>
<p>
	The <strong>Don't start dropped</strong> flag, on the other hand, makes the item to still be affected by gravity, but it will not spawn already dropped the floor directly below it (I.E. it won't run droptofloor() upon spawn). This way the item will fall to the floor only after it has been spawned.
</p>

<h3 id="item-style">Item box model style</h3>
<p>
	By default, Alkaline uses the higher-detail BSP item box models from Rubicon Rumble Pack, but you also have the option to use MDL item boxes by Markie - with proper fullbright parts so you can still see them in the dark. You can select it through the <strong>itemstyle</strong> key, either on worldspawn to set it globally, or directly on a per-entity basis.
</p>

<hr>

<h2 id="weapons">Weapons</h2>

<p>In your arsenal, some old acquaintances have made a return in Alkaline, but there's new stuff too.</p>

<h3 id="new-weapons">New weapons</h3>

<ul>
	<li><strong>Proximity Mine Launcher:</strong> </li>
	<li><strong>Laser Cannon:</strong> The good-old laser-ricochet chaos-inducing weapon from Scourge of Armagon makes a comeback in Alkaline.</li>
	<li><strong>Chainsaw:</strong> The chainsaw from Zerst√∂rer, with a cool new model, animation and effects, if you like to get up close and personal with your foes.</li>
	<li><strong>Plasma Rifle:</strong> A completely new weapon! Not the most powerful energy weapon, but it's great for mowing down large groups of enemies as quickly as it mows down your cells.</li>
</ul>

<p>The Laser Cannon and the Plasma Rifle are placed in the same slot as the Lightning Gun, and alternate between them when you press their key, but can be selected directly through impulses <strong>225</strong> and <strong>227</strong>, respectively, so you can bind them to an individual key if you like. Also the Lightning Gun can be directly selected with the impulse code <strong>228</strong> without cycling through the other energy weapons.</p>
<p>The same happens to the Chainsaw, which sits along with the Axe, but can be directly selected through impulse <strong>224</strong>.</p>

<h3 id="custom-loadout">Custom loadout</h3>
<p>You can define a completely custom loadout at map start using the <strong>take_weapons</strong> and <strong>give_weapons</strong> worldspawn keys, as well as each of the ammo types.</p>
<p>First, Alkaline will remove the ones checked in <strong>take_weapons</strong>, then give the ones selected in <strong>give_weapons</strong>. So, if your map would begin with a "shotgun start" (I.E. default inventory), taking away the axe and the shotgun will make the player start with no weapons at all.</p>
<p>Setting any of the <strong>ammo_*</strong> keys will override the current amount with the defined one.</p>
<p>Also, setting the <strong>reset_items</strong> worldspawn key to 1 will force a "shotgun start" on your map regardless of inventory/stats coming from a previous map. Note that the inventory reset is made before applying take/give weapons.</p>

<h3 id="axe-shotgun">Axe and shotgun pickups</h3>
<p>Since you have the option to remove the axe and the shotgun from your inventory, we've added them as traditional weapon pickups as well. Deploy them through the <strong>weapon_axe</strong> and <strong>weapon_shotgun</strong> point entities.
</p>

<h3 id="target_removeitems">target_removeitems entity</h3>
<p>Acts the same way as the <strong>take_weapons</strong> worldspawn key, but can be used mid-level. Trigger it to remove the selected weapons from the activating player.</p>

<h3 id="particle-impact">Custom impact particle effect</h3>
<p>You can override the default particle effect when shot for every shootable entity, including monsters, breakables, buttons and doors. For that, you must manually add a <strong>bloodtype</strong> key to it, and give it one of the following values: </p>
<ul>
<li>1: Blood</li>
<li>2: Standard grey chunks</li>
<li>3: Brown dirt</li>
<li>4: Yellow sparks</li>
<li>5: White sparks</li>
</ul>


<hr>
<h2 id="triggers">Triggers</h2>

<p>In Alkaline we've gone great lengths to allow advanced scripting and events.</p>

<h3 id="multiple-targets">Multiple targets</h3>
<p>Following Copper's fashion, Alkaline also supports the <strong>target2/target3/target4</strong> keys but not multiple targetnames, as it increases code complexity and stack usage multi-fold. Having only multiple targets is usually enough to cover most cases, and you can always set up some relays if necessary.</p>

<p>An exception is made for some entities that must control or modify other entities that could have their behavior changed when given a targetname, so they can also target a <strong>targetname2</strong> field. Note that the targetname2 field isn't displayed on any entity by default, so you must add it manually when needed. The following entities have that ability:
</p>
	<ul>
		<li><strong>target_setstate</strong></li>
		<li><strong>target_setdoor</strong></li>
		<li><strong>target_move</strong></li>
		<li><strong>misc_shadowcontroller</strong></li>
	</ul>

<h3 id="dormant-triggers">Dormant triggers</h3>
<p>One of the first changes to triggers that every mod usually do is allow them to be trigger spawned, and with Alkaline that wouldn't be different. Set <strong>is_waiting</strong> to 1, and the trigger won't be active until you target it. It works with all touchable trigger brush entities.</p>

<h3 id="monster-triggerable">Monster-activated triggers</h3>
<p><strong>trigger_once</strong> and <strong>trigger_multiple</strong> can be set to be activated by monsters as well as players, so you can set them to fall into traps for example.</p>

<h3 id="message-all">Message all players</h3>
<p>Every entity that can centerprint a message may be set to broadcast it to all connected players. Good for when you have some map-wide event that you want to communicate in a co-op game for example. Just set the spawnflag <strong>message all players</strong> on the messaging entity.</p>

<h3 id="trigger_repeat">Repeater/timer trigger</h3>
<p>The <strong>trigger_repeat</strong> entity is a point entity that fires its targets repeatedly on a defined interval after activated. Can keep firing indefinitely or for a limited number of times. Targeting it again stops the firing.</p>
<p>The counter can be optionally not be reset after triggering it again (spawnflag 1), so it functions more like a pause/unpause.</p>

<h3 id="monsterjumps">Monsterjumps</h3>
<p>The <strong>trigger_monsterjump</strong> entity comes with some new features. You have now a simple monster-class-based filter, so you can let only a single monster class to be affected by it, or exclude a specific one from it.</p>

<h3 id="hurt">Hurt triggers</h3>
<p>The <strong>trigger_hurt</strong> brush entity works the same as before, but has 2 new features:</p>
<ul>
<li>Damage interval and amount can both be customized.</li>
<li>You can set it to not hurt players and/or monsters.</li>
</ul>

<p>The new <strong>target_hurt</strong> entity is a point version of that. It hurts any entity activating it, or the entities defined in its target-target4 fields.</p>

<h3 id="stealth-teleport">Stealth teleport</h3>
<p>Stealth mode can be set on both <strong>trigger_teleport</strong> (when teleporting out) and <strong>info_teleport_destination</strong> (when teleporting in).</p>

<h3 id="multiple-destinations">Multiple teleport destinations</h3>
<p>A single <strong>trigger_teleport</strong> can target multiple <strong>info_teleport_destination</strong> entities with the same targetname.</p>
<p>There are 3 ways in which the trigger can deal with that:</p>
<ul>
<li><strong>First</strong> mode (default): always selects the destination with the lowest <strong>count</strong> value. This way you can disable a specific destination with a <strong>target_setstate</strong> when you want the teleport to target the next one;</li>
<li><strong>Random</strong> mode: selects a destination randomly;</li>
<li><strong>Cycle</strong> mode: goes sequentially through destinations every time the teleport is used, according to their <strong>count</strong> field ordering.</li>
</ul>
<p>Refer to the in-editor documentation for both <strong>trigger_teleport</strong> and <strong>info_teleport_destination</strong> for more info.</p>

<h3 id="mapvars">Mapvars</h3>
<p>Mapvars are miscellaneous flags (only true/false values) that can be freely used by the mapper whose values persist across level changes. Useful to track completion progress on mapjams for example. You have a total of 44 flags availabe to use, each identified by a number in the 1-44 range.
</p>
<p>You can access them through 2 point entities:</p>
<ul>
<li><strong>trigger_mapvar_write</strong>: Writes a value to a specified mapvar. Can either set to on, to off, or toggle the current mapvar value.</li>
<li><strong>trigger_mapvar_read</strong>: Tests a mapvar against a specified value, and relays the trigger if the condition is met. When given a targetname, it'll read/relay when triggered. Otherwise, it'll fire automatically once after the map starts - good for modifying map structures or enabling/disabling triggers right from the start.</li>
</ul>
<p>Also, you can define a mapvar to be enabled automatically in <strong>trigger_changelevel</strong> entities when the player goes through it.</p>

<h3 id="mapstart">Multiple map starting spots</h3>
<p>You can have multiple player start spots in your map. <strong>trigger_changelevel</strong> entities accept a <strong>count</strong> key, which on the next map will try to direct the player to an <strong>info_player_start</strong> spot with a matching <strong>count</strong> value. That's also true for coop starts.</p>

<hr>

<h2 id="doors">Doors</h2>
<p>The good old <strong>func_door</strong> in Alkaline has been completely revamped.</p>

<h3 id="door-distance-angle">Distance and angle</h3>
<p>You have various ways of setting the door's movement:</p>
<ul>
<li>using the traditional <strong>angle</strong> and <strong>lip</strong> keys</li>
<li>using <strong>angle</strong>, but with <strong>distance</strong> instead of lip, to specify a travel distance directly</li>
<li>setting <strong>movedir</strong> as a direct distance vector ("x y z") relative to its initial position</li>
<li>setting <strong>mangle</strong> and <strong>distance</strong> to make it move in any arbitrary angle ("pitch yaw 0") and linear distance</li>
</ul>

<p>Note that those methods are mutually exclusive, so if you use one of those, remember to remove the keys relative to the others, or else you might have some unexpected behaviour.</p>

<p>You can now set a different closing speed for the door with the <strong>speed2</strong> key. If unset, it'll use the same value as <strong>speed</strong>.
</p>

<h3 id="door-delay">Delayed movement</h3>
<p>With this feature you can create more complex multi-entity doors with parts that move independently, but still act like a single door. You can set delayed movement for a door part with the <strong>delay</strong> key, and the timings are automatically reverted when closing, which means that the first door entity to open will be the last to close.</p>

<p><strong>delay2</strong> sets an additional delay for when the door closes. Useful if you need to wait for another door part to set in position before moving.</p>

<h3 id="door-linking">Door grouping/linking</h3>
<p>For the delayed movement feature to work as intended, a great deal of work was put into making sure they'll link correctly. By default, all doors whose bounding boxes touch or intersect will belong to a single group, and will always move at the same time. But now you also have the option to manually group them through the <strong>groupname</strong> key. Doors with this field set will ignore the touching algorithm for linking, and will only group with other doors that have the same groupname, regardless of where they're positioned in the map.</p>

<p>That also means that the old-time bug with toggling dual-doors was corrected, so you don't need to set "don't link" anymore for toggling doors.</p>

<p>It's recommended that you set the same key values on all doors in the group, like targets, wait, messages, keys, except those specific for each door part, like angle, distance, speed, delay, sound, etc.</p>

<h3 id="door-sounds">Sounds</h3>
<p>You can set completely custom sounds to doors. They'll override the default sounds selected through the <strong>sounds</strong> key (either on the door itself or on worldspawn).</p>
<ul>
	<li><strong>noise1</strong>: Sound file for the 'stop moving' sound</li>
	<li><strong>noise2</strong>: Sound file for the 'moving' sound (a looping sound file is recommended)</li>
	<li><strong>noise3</strong>: Sound file for the 'key required' sound</li>
	<li><strong>noise4</strong>: Sound file for the 'key used' sound</li>
</ul>
<p>
	Due to the new delayed movement features, the new spawnflag <strong>Sound during delay</strong> was added. When set, it'll make this specific door part to start its move sound at the instant the whole group starts moving, and only play the stop sound when all doors finished moving. This way you're able to set a single door in the group to sound during the whole movement sequence, and avoid multiple start/stop sounds overlapping for each entity.
</p>

<h3 id="door-keys">Keys</h3>
<p>You can set a door to demand a custom key through the <strong>keyname</strong> field. The keyname must match the one in a <strong>item_key_custom</strong> entity. Refer to the item_key_custom documentation in-editor for more details.</p>

<p>There are two other key-related options:</p>
<ul>
	<li><strong>cnt</strong> key: If set to 1, the player won't have the key removed from their inventory when unlocking, but the door will stay open as usual.</li>
	<li><strong>Doom style unlock</strong> spawnflag: Setting this allows the door to function like a conventional door (opens and closes) after it's been unlocked. It also makes players retain the key in their inventory.</li>
</ul>


<h3 id="door-set-position">Setting a door position directly</h3>
<p>The <strong>target_setdoor</strong> point entity can directly command a door to open or close, regardless of which state it's in. The <strong>style</strong> key sets the command issued to the targeted door when this entity is triggered. Note that doors with a wait time set will still close again normally afterwards.</p>
<p>If you need to command a door and still want it to retain its "touch to open" behavior, you can make the setdoor entity target the door's <strong>targetname2</strong> field..</p>

<h3 id="door-trigger-field">Trigger field</h3>
<p>The door's trigger field is the built-in trigger that makes the door open when something gets close to it. Alkaline gives you some more control over how it's created, or allows to make a completely custom one.</p> 
<p>The default door trigger field size in Quake extends 60 units beyond the whole door's bounding box in both X and Y directions. Through the spawnflags <strong>Expanded/reduced trigger field</strong>, you can set the trigger field to be expanded by another 24u, or reduced by 52u, in either X or Y direction. If you set both expand and reduce at the same time, they'll sum up, so you'll get a smaller reduction of 28u.</p>
<p>Also, you have the option of using the <strong>trigger_doortriggerfield</strong> brush entity. With it you can define a custom trigger field. Just make it target a door, and it'll override the built-in one.</p>
<p>Last but not least, standing monsters won't open doors anymore, so you can safely put an enemy ambushing behind one without it staying open.</p>

<hr>
<h2 id="plats">Plats</h2>

<p>Besides the traditional func_plat, we've added DoE's <strong>func_new_plat</strong> entity, which is a lot more flexible and feature-packed.</p>
<p>You can select between multiple plat modes through its spawn flags:</p>


<h3 id="plat-start-at-top">Plat start at top</h3>
<p>It's a plat that starts at the top and when triggered, goes down, waits, then comes back up. The <strong>health</strong> field sets the number of seconds to wait (default 5)</p>

<h3 id="plat-toggle">Plat Toggle</h3>
<p>Creates a plat that will change between the top and bottom each time it is triggered.</p>

<h3 id="plat-elevator">Elevator</h3>
<p>Makes an elevator plat. You can have as many levels as you want but they must be all the same distance away. Use the <strong>func_elvtr_button</strong> entity as the trigger. Each floor must have its own panel with func_elvtr_buttons for the elevator to move correctly.</p>

<p><strong>"Elevator Start at Top"</strong> is an optional flag for elevators. It just tells the elevator that it's position is the top floor. (Default is the bottom floor) USE THIS ONLY WITH ELEVATORS!</p>

<h3 id="plat2">Plat2</h3>
<p>'Plat2' is a fixed version of the original plat. If you want the plat to start at the bottom and move to the top on demand, use a negative height. That will tell Quake to lower the plat at spawn time. Always place this plat type in the top position when making the map. This will ensure correct lighting, hopefully. If a plat2 is the target of a trigger, it will be disabled until it has been triggered. Delay is the wait before the plat returns to original position.</p>

<h3 id="other-plat-features">Other new features</h3>

<p>The following features are present in both <strong>func_plat</strong> and <strong>func_new_plat</strong>:</p>
<ul>
	<li><strong>Custom sounds</strong>: can be set through the <strong>noise/noise1</strong> keys.</li>
	<li><strong>Deep trigger</strong> spawnflag: makes its trigger field go all the way to the bottom of the entity's lower position, instead of starting at the top of the lower position. For when you need to ride INSIDE of the plat entity's volume, not on top of it.</li>
</ul>

<hr>

<h2 id="trains">Trains</h2>

<p><strong>func_train</strong> have got some more tricks.</p>

<ul>
<li>Giving a <strong>path_corner</strong> a <strong>wait -1</strong> value will stop the train, and triggering the train again makes it resume its path.</li>

<li><strong>path_corner</strong> can change the train speed upon arriving at it.</li>

<li><strong>path_corner</strong> will have its targets fired when the train passes by.</li>

<li>Setting <strong>pausetime</strong> on the train sets a default waiting time when a value is not defined in path_corners.</li>

<li>The train can be given custom sounds through the <strong>noise</strong> and <strong>noise1</strong> keys.</li>

<li><strong>Move on trigger</strong> spawnflag will force the train to resume its path when triggered, even when temporarily waiting at a path_corner.</li>

<li><strong>Stop on trigger</strong> spawnflag will stop the train at the next path_corner when triggered. Trigger it again to resume.</li>
</ul>
<p>The flags above are mutually exclusive and will cause an objerror when selected simultaneously.</p>

<h3 id="modeltrain">Model trains</h3>
<p><strong>misc_modeltrain</strong> works the same way as a func_train, but for using with external models.</p>
<p>The model can smoothly orient itself towards the next path_corner when moving. The turning speed is automatic and based on the movement speed, but you can set a multiplier for the turning speed with the <strong>multiplier</strong> key. Set it to -1 to turn instantly.</p>
<p>You can define two different frame ranges and animation speeds, for when the model is stopped and moving. If you don't need different stopped/moving animations, only setting <strong>first_frame</strong>/<strong>last_frame</strong>/<strong>frtime</strong> is enough. If you don't need any animation at all, just set <strong>first_frame</strong> to the desired frame and all other fields can go blank.</p>
<p>Make sure to check the in-editor documentation for more details on other specific options.</p>

<hr>

<h2 id="state-system">State System</h2>

<p>Alkaline has a state system somewhat similar to AD's "estate" system and Copper's target_lock entity. With it you can disable/enable entities at will, giving you greater control over complex map scripting and events. Entity behaviour when disabled is class-dependant.</p>
<p>You set an entity's state using the <strong>target_setstate</strong> point entity. You can directly disable, enable, or toggle the state. Target entities can start the map already disabled through the spawnflag <strong>Targets start disabled</strong>.</p>
<p>If you need to target an entity that has its behaviour changed when given a targetname (like <strong>func_door</strong> or <strong>trigger_teleport</strong>), you can make the <strong>target_setstate</strong> target the entity's <strong>targetname2</strong> field.</p>
<p>This system is integrated with dormant triggers (<strong>is_waiting</strong> key), meaning that you can "wake" a trigger not only by triggering it, but also by using a <strong>target_setstate</strong> on it.</p>
<p>The entity's state is kept under the <strong>estate</strong> field, which 0 meaning enabled/normal operation, and 1 disabled. So for triggers, you're able make them start off by to directly setting this value to 1. You cannot do that to doors nor buttons though, in those cases you need to use a target_setstate with "start disabled" set.</p>
<p>A lot of entities support enabling/disabling:</p>

<h3 id="state-triggers">Trigger brushes of any class</h3>
<p>When disabled, all <strong>trigger_*</strong> brush entities get their touch action turned off. This includes self-sufficient entities that don't need to target anything, like fog triggers, ladders, monsterjumps, changelevels, etc.</p>
<p>Also, any entity that fire their targets won't do it while disabled (like <strong>trigger_relay</strong>), and a <strong>trigger_counter</strong> won't get its use count increased.</p>

<h3 id="state-doors">Doors</h3>
<p>Like in Copper, disabling a door makes it not respond to touches or triggers, and disables its trigger field.</p>
<p>Doors will also close immediately when disabled. Toggling doors or with <strong>wait -1</strong> set won't close by default, but you can change that behaviour using the spawnflag <strong>Close all doors</strong>. In this case, if re-enabled, the door will return to the position it was before disabling.</p>

<h3 id="state-buttons">Buttons</h3>

<p>Also similar to Copper, buttons depress themselves when disabled and cannot be activated.</p>
<p>If the button have a <strong>wait -1</strong> value (that is, it's a press-once button), when re-enabled it'll reset back to its un-pressed state regardless if it had been activated before. You can change that using the spawnflag <strong>Don't reset button state</strong>, in which case it'll revert to its previous state when re-enabled.</p>

<hr>

<h2 id="advanced-triggering">Advanced triggering</h2>
<p>Alkaline has some very advanced scripting through some specialized entites.</p>

<h3 id="trigger_filter">trigger_filter</h3>
<p>This point entity relays only if a given condition evaluates to true, unleashing ultimate scripting capabilites. You can test various fields on the entity targeted by the <strong>include</strong> field (you can target another entity's <strong>targetname2</strong> as well). If you let the <strong>include</strong> field empty, it'll test against the activating entity instead, be it a player, a monster or anything else - see <strong>trigger_everything</strong> below for more details.</p>

<p>You can, for example, relay a trigger only if a door or plat is in a certain position, or if a targeted enemy is alive or dead or below a certain health amount, or if the player is carrying some specific weapon or item, or if the activator is a certain type of weapon projectile - the possibilites are almost endless.</p>

<p>In case you're filtering to activate only in case if it's a specific weapon projectile (like a grenade for example), you can make the targets fire with the activating entity's owner as the activator with the spawnflag <strong>Relay activator as owner</strong> - say, if the trigger is activated by a player's grenade, it'll fire with the player as activator, instead of the grenade itself.</p>

<p>There are various fields available to test, selectable through the <strong>style</strong> key. They all fall into three field types (float, flag and string), and for each there's a set of operations available to evaluate, selectable through the <strong>weapon</strong> key.</p>

<ul>
	<li>Float types can do all operations, and are compared to this entity's <strong>count</strong> field.</li>
	<li>Flag types support Equal and bitwise AND, and are compared to the <strong>aflag</strong> field.</li>
	<li>String types have only Equal evaluation, and are compared to this entity's <strong>type</strong> field.</li>
</ul>

<p>You can set the trigger to fire if the condition evaluates to false by activating the spawnflag <strong>Trigger if false</strong>. It'll never fire if the entity targeted by <strong>include</strong> isn't found, regardless of this spawnflag.</p>

<p>If you need to evaluate more than one condition, you can chain multiple filters in a row.
Also, the state of the last evaluation is stored in this entity's <strong>state</strong> field (1 for fired, 0 for not fired).</p>

<h3 id="trigger_everything">trigger_everything</h3>

<p>A no-holds-barred touchable solid trigger. Everything triggers it. Players, monsters, projectiles, gibs, even other solid entities like doors and plats.</p>

<p>It can only fire targets matching its <strong>target</strong> field. Due to its "fire-all" nature, it doesn't have support for the 'target2-4' fields, neither 'message' nor 'killtarget'. Useful when used in conjunction with the <strong>trigger_filter</strong> point entity to filter out its firing.</p>

<p>By default it'll fire for each and every registered touch, even if simultaneous. If given a <strong>wait</strong> value, it'll act like a trigger_multiple, where a single activation puts it on hold for <strong>wait</strong> seconds. If the target is a trigger_filter, you can set it to wait only if the filter evaluates to true through the spawnflag <strong>Wait only if trigger_filter evaluates to true</strong>.</p>

<h3 id="target_setcount">target_setcount</h3>
<p>Changes the targeted entity's <strong>count</strong> field. Targets both targetname and targetname2 fields.
Can be used with a <strong>trigger_filter</strong> to dinamically change its float comparing value, or to reset/change a <strong>trigger_counter</strong>'s current use count.</p>

<p>You can either replace the current value with a new one, or add to/subtract from it (using a positive or negative <strong>count</strong>), by selecting into the <strong>style</strong> field.</p>

<hr>
<h2 id="shadows">Shadows</h2>

<h3 id="func_shadow">func_shadow entity</h3>
<p><strong>func_shadow</strong> is a brush entity with a simple function: cast shadows. It's not visible nor clips nor does anything else ingame. In order for it to work correctly you need to either set a <strong>_shadow 1</strong> or a <strong>_switchableshadow 1</strong> key in it.</p>
<p>It's useful if you need to simulate a shadow being cast by a misc_model for example, or create more complex lighting schemes using switchable shadows (more on that below).</p>

<h3 id="switchable-shadows">Switchable shadows</h3>
<p>Alkaline has full-on support for switchable shadows if your compiling tools can handle it. Every brush entity, except triggers and <strong>func_detail_*</strong> ones, can have togglable shadows by adding a <strong>_switchableshadow 1</strong> key to it.</p>
<p><strong>func_door</strong>, <strong>func_breakable</strong> and <strong>toggle_visiblewall</strong> already have built-in support for that, so all you need to do is add the key for it to work automatically. Also, any killtargeted entity (like a <strong>func_wall</strong>) with a switchable shadow will have it removed automatically.</p>

<p>For other entity classes, like <strong>func_shadow</strong>, you need to set up a <strong>misc_shadowcontroller</strong> point entity to control their switchable shadows. That's how you do it:</p>
<ul>
	<li>Create a <strong>_switchableshadow</strong> key in the desired entity and set it to 1;</li>
	<li>Give it a <strong>targetname</strong> - if the entity changes behaviour when given a targetname, you can target a <strong>targetname2</strong> field instead.</li>
	<li>Create a <strong>misc_shadowcontroller</strong> entity targeting the bmodel, and give it a different targetname.</li>
	<li>Triggering the shadow controller toggles the shadow on/off with a fading animation.</li>
</ul>

<p>Currently, ericw's LIGHT tool supports switchable shadows only when the map isn't using bounce lighting. That's been already corrected in development versions however, and should be out in its next release.</p>
	
<hr>

<h2 id="lights">Lights</h2>

<p>
	Lights in Alkaline have some new notable features.
</p>

<h3 id="enhanced-light-toggling">Enhanced Toggling</h3>
<p>A feature brought over from progs_dump, animated lights (flickering/pulsing) can now be toggled. Give it a targetname as usual, but set the light style into the <strong>style2</strong> key. Then it'll toggle like any other light.</p>
<p>You can also set the light to fade it in/out when toggling by setting the spawnflag <strong>Fade in/out</strong>, and control the fading time with the <strong>speed</strong> key. Note that this effect won't work when toggling animated lights.</p>

<h3 id="target_lightstyle">Setting a light's style directly</h3>
<p>The <strong>target_lightstyle</strong> point entity can modify a light's style. It's the same one from Copper, so quoting its <a href="http://lunaran.com/copper/mapping/#target_lightstyle">docs</a> directly:</p>
<blockquote>
	<p>target_lightstyle gives the mapper direct control over the pattern of any of the 64 lightstyles when triggered. Styles 1-31 are the preset lightstyles, and 32-64 are assigned by the compiler to triggered lights, and both can be overridden. Set style to the lightstyle you want to override, and set message to the brightness pattern you want to set it to. If style is not set, and this entity targets any triggerable lights, it sets the brightness pattern of those lights when triggered instead. (Note that targeting anything at a light makes it a triggerable light with its own style automatically.) This is compatible with any Quake map compiler, because light.exe only cares about the style number - the pattern is only applied in-game.</p>

	<p>Setting style to -1 will override the style of all static, unstyled lights in the level (style 0).</p>

	<p>Multiple additional stylestrings can be specified in order using the noise and noise1-noise4 keyvalues. The target_lightstyle will cycle to the next unused one each time it is triggered.</p>

	<p>Quake's light patterns are sequences of characters where each letter represents a brightness from 0-200% lasting 0.1 seconds, allowing long animations to be packed into an editable string. a represents total darkness, m is normal brightness, and z is double brightness. For example, the painful disco strobe in the Fiend-filled corridor in E3M5, The Wind Tunnels, is "mamamamamama". Implementing a standard on/off toggle would use a message of "a" and a noise of "m" or "z".</p>
</blockquote>

<h3 id="new-light-fixtures">New light fixtures</h3>

<p>There are 2 new decorative light entities.</p>
<ul>
	<li><strong>light_fixture1</strong>: wall-mounted light fixture. Control the model's turning angle with the <strong>angle2</strong> field. Note that this angle won't be shown in the editor, only in-game.</li>
	<li><strong>light_beacon</strong>: Floor-mounted red beacon. Has an optional blinking animation, that syncs with light style 16.</li>
</ul>

<hr>

<h2 id="fog">Fog</h2>

<p>Alkaline comes with an improved version of Copper's dynamic fog system.</p>
<p>You can set a fog value into all player start entities, teleport destinations, and intermission cameras, so the fog will change instantly to the set value when a player makes use of them. This way, the player's view can move to a different fog zone without having to pass through a fog trigger.</p>
<p>An important note from Copper about this fog system:</p>
<blockquote>The fog keyvalue that goes on Worldspawn doesn't interact with this system. It is a feature of various engines (such as those in the Fitzquake family) and isn't interpreted by game code. The reason for this is that it's interpreted as four values (one for density and three for color) and set by the engine at load time. The numeric fields that are passed on to the game code (ie Copper), however, can only be one value (a float) or three (a vector). If you set fog in your world with a fog parameter on worldspawn, and never bother with fog_color and fog_density on any entities, you'll get the usual static global fog the way it's always worked. Color and density on a player start will be evaluated on the first frame of gameplay, and will override any fog set by the engine.</blockquote>
<p>Setting the fog density to -1 will disable the fog.</p>

<h3 id="trigger_fogblend">Blending fog between two areas</h3>
<p>Using the <strong>trigger_fogblend</strong> brush entity, you can smoothly blend between two fog values as the player moves across the trigger. It's not temporal-based, instead it's based on how far the player moves within it.</p>
<p>This way, you can place one along a corridor for example, and the fog will seamlessly change as the player walks.</p>

<h3 id="target_fogblend">Time-based fog blending</h3>
<p>The <strong>trigger_fog</strong> brush entity blends the player's current fog into another when touched, within a customizable transition time.</p>
<p>And the <strong>target_fogblend</strong> point entity toggles the activating player's fog between two different settings, also with a custom transition time. The first activation makes it blend in from the current fog, and the subsequent ones make it toggle between two values. You can optionally set the fog to be applied to all players.</p>

<h3 id="skyfog">Sky fog</h3>
<p>All entities that change the fog can change skyfog density as well, with the key <strong>skyfog_density/skyfog_density2</strong>. The same transitions to the usual fog apply to skyfog.</p>
<p>If you want to disable skyfog, set the field to -1. Leaving it unset, or set to 0, will keep the skyfog unchanged. In case you want to change only the skyfog density and not change the standard fog, set <strong>fog_density</strong> to 0.</p>

<hr>

<h2 id="solids">Solids</h2>

<h3 id="breakables">Breakables</h3>
<p>A <strong>func_breakable</strong> is a visible object that can be destroyed by shooting it. If it has a targetname, it will only be destroyed by targeting it.</p>
<p>You have 4 debris variations, each with a different debris model and accompanying sound effect (<strong>style</strong> key). You can also customize which particle effect will be spawned when the breakable get shot (<strong>bloodtype</strong> key).</p>

<h3 id="togglable-brushes">Walls and togglable brushes</h3>
<p>There are 2 togglable brush entities:</p>
<ul>
	<li><strong>func_togglewall</strong>: Creates an invisible clipping wall that can be toggled on and off. Blocks movement and gunfire when active.</li>
	<li><strong>func_togglevisiblewall</strong>: A togglable, visible brush model. Besides the toggling mechanism, it functions like a func_wall in any other way. Can be set to be non-solid.</li>
</ul>

<h3 id="misc_model">misc_model</h3>
<p>You can add any custom model to your map through the <strong>misc_model</strong> entity to use as props or decoration. Targeting the entity toggles its visibility.</p>
<p>Any frame or skin can be selected. If the model doesn't animate automatically from a frame group, you can manually define a frame range and animation speed.</p>
<p>The model's bounding box can be totally customized by setting its size and center offset. Also it can be set to be affected by gravity and/or be solid.</p>


<h3 id="rotators">Rotators</h3>
<p>Alkaline comes with the well-known Hipnotic's rotate entities. You can refer to <a href="https://tomeofpreach.wordpress.com/quoth/tutorial/rotation-overview/">czg's in-depth tutorial over Preach's Blog</a> on how to use them.</p>

<h3 id="exploboxes">Exploboxes</h3>
<p>Besides the usual <strong>misc_explobox</strong> point entities, there's a <strong>func_explobox</strong> brush entity that works exactly the same way but can be made in any shape.</p>
<p>Both <strong>misc_explobox</strong> and <strong>func_explobox</strong> fire their targets when exploding, and can be blown up remotely by triggering them.</p>

<h3 id="laser">Laser</h3>
<p>The <strong>func_laser</strong> brush entity creates a togglable laser with a faint flickering alpha effect. Hurts to touch, can be used to block players. We recommend to use it with a fullbright-colored texture for better looks.</p>

<h3 id="ladders">Ladders</h3>
<p><strong>trigger_ladder</strong> creates an invisible ladder entity. When player is touching it, he can climb by pushing "jump".</p>

<h3 id="bobbing">Bobbing</h3>
<p>You can create entities that gently moves back and forth in any direction. <strong>func_bob</strong> is a brush entity, and <strong>misc_bob</strong> is a point entity that uses external models.</p>


<hr>

<h2 id="sounds-music">Sounds and music</h2>
<p>The mod comes with various options for you to play your custom sounds.</p>

<h3 id="triggered-sounds">Triggered sounds</h3>
<p>Use the <strong>play_sound_triggered</strong> to plays an one-off sound when triggered.</p>
<p>The <strong>play_sound</strong> entity plays a sound on a periodic/random basis, like thunder effects for example. Not recommended for ambient sounds.</p>

<h3 id="ambient-sounds">Ambient sounds</h3>
<p>The <strong>ambient_general</strong> point entity lets you place a customized ambient sound. For it to work, make sure the sound file contains cue points for looping. Can be given customized volume and attenuation settings.</p>
<p>Also, the built-in <strong>ambient_*</strong> entities now can have their default volume/attenuations changed as well.</p>

<h3 id="music">Music</h3>
<p>The <strong>misc_changemusic</strong> entity changes the current map's music track number to the one specified in the <strong>sounds</strong> field when triggered. If you set the track to 1, the music will stop.</p>

<hr>
<h2 id="environmental-effects">Environmental Effects</h2>

<h3 id="void">Void</h3>
<p>The <strong>trigger_void</strong> brush entity removes from the world everything that touches it, such as monsters, items, gibs and weapon projectiles. Players get instantly killed, even while wearing the Pentagram or the Trifecta.</p>

<p>Also, the <strong>func_wall</strong> can be made non-solid, making it similar to a targetable func_illusionary.</p>


<h3 id="gravity">Gravity</h3>

<p>You can change the gravity in two ways:</p>
<ul>
	<li><strong>Globally:</strong> The <strong>trigger_globalgravity</strong> point entity toggles the world gravity between two settings when triggered (<strong>gravity</strong> and <strong>return_gravity</strong> fields).</li>
	<li><strong>Locally:</strong> The <strong>trigger_setgravity</strong> brush entity changes the gravity of each entity that touches it.</li>
</ul>


<h3 id="explosions">Explosions</h3>
<p><strong>target_explosion</strong> creates explosions on demand, with the same appearance as a rocket/grenade blast. Can explode once on triggering, or be set to fire off on a periodic basis.</p>
<p>Damage can be customized - for reference, an Ogre's grenade blast does 40 damage, while a player's rocket hit deals 120 damage. Set it to 0 for a purely cosmetic effect.</p>

<h3 id="particle-field">Particle field</h3>
<p>The <strong>misc_particlefield</strong> brush entity makes dots appear continuously within its bounds. Trigger to toggle on/off.</p>

<h3 id="lightning-trail">Lightning trail</h3>
<p>You can create lightning trails using the <strong>misc_lightning_start</strong>, <strong>misc_lightning_relay</strong>, and <strong>misc_lightning_end</strong> point entities.</p>
<p>The trail always must start with a <strong>misc_lightning_start</strong> and end with a <strong>misc_lightning_end</strong>, but you can place some <strong>misc_lightning_relay</strong> between those if you need the trail to go into a different direction midway.</p>

<h3 id="screen-shake">Screen shake</h3>
<p><strong>target_screenshake</strong>, from <a href="http://lunaran.com/copper/mapping/#target_screenshake">Copper</a>:</p>
<blockquote>
	<p>Shakes the screen when triggered. Jostles the view of all clients, but doesn't physically move their bounding boxes or apply velocities. Set its intensity with <strong>strength</strong>. 1 is a hearty rumble, 10 is spasmodic bordering on hilarious.</p>

	<p>Follows an attack-sustain-release curve: it builds for <strong>delay</strong> seconds, holds at full strength for <strong>length</strong> seconds, then fades back toward zero for <strong>wait</strong> seconds. Total quake duration is therefore delay + length + wait. All three have defaults, but any of them can be forced to 0 by setting them to -1. (You might want a quake with no delay to be caused by a sudden blast, for example.)</p>
</blockquote>

<h3 id="text-story">Story texts</h3>
<p>To show long story texts, for logs, terminals, books, etc., you can use the <strong>trigger_textstory</strong> brush entity. It shows a message that remains on-screen while the player is inside the trigger volume.</p>
<p>You can set it to be show the message only when the player is facing a certain angle within the trigger. Set the central angle with <strong>mangle</strong>, and the maximum angle offset with <strong>view_ofs</strong> (both in 'pitch way 0' format).</p>
<p>You can define custom sounds as well, both for when the message is shown (<strong>noise1</strong>) and when it fades away (<strong>noise2</strong>). Use "misc/talk.wav" for the default centerprint beep.</p>
<p>There's a point entity variant called <strong>target_textstory</strong>. When triggered, it'll show the message on-screen for the duration defined in <strong>wait</strong>.</p>


<h3 id="other-effects">Other effects</h3>
<ul>
	<li><strong>Trap shooters:</strong> Now can fire rockets, and have projectile speed and damage customized.</li>
	<li><strong>Laser turret:</strong> the <strong>func_turret</strong> brush entity creates a rotating laser shooter that aims at the player in any horizontal direction.</li>
	<li><strong>Smoke:</strong> From Rubicon2, there's the <strong>misc_smoke</strong> point entity. Produces a jet of smoke/steam. If targeted, it will toggle between on or off.</li>
	<li><strong>Sparks:</strong> the <strong>misc_sparks</strong>, also from Rubicon2. Produces a burst of yellow sparks at random intervals. If targeted, it will toggle between on or off.  If it targets a light, that light will flash allong with each burst of sparks.</li>
	<li><strong>Meat/gibs:</strong> <strong>target_meat_fireworks</strong>. Does what it says on the tin. Meat fireworks. Can be fired once or on a periodic basis.</li>
	<li><strong>Teleport fog:</strong> Targeting a <strong>target_telefog</strong> produces a teleport fog effect when triggered, sounds and all.</li>
	<li><strong>Particle splash:</strong> <strong>misc_splash</strong> produces a continuous particle splash for waterfalls.</li>
	<li><strong>Bullet holes:</strong> adding a <strong>nobullets</strong> with a value of 1 to any brush entity prevents it from getting bulletholes.</li>
</ul>

<hr>
<h2 id="enhancements">Other Enhancements</h2>

<h3 id="autosaves">Autosaves</h3>

<p>The <strong>target_autosave</strong> point entity saves the game when triggered, and does so by default in a slot named "auto". We've included a default bind for the F8 key that loads from this slot.</p>
<p>The same autosave entity can be used multiple times, so you don't need to place a new one for each save point if you don't want to.</p>

<h3 id="episode-ending">Episode-ending screen</h3>
<p>You can create a custom episode-ending screen by giving the <strong>trigger_changelevel</strong> a text into the <strong>message</strong> field.</p>
<p>Note that the screen width available only fits 40 characters at most, so you need to manually include line breaks (<strong>\n</strong>) into your text if necessary.</p>

<h3 id="target_move">target_move</h3>
<p>Using this point entity you can move any other entity to its origin upon triggering. Works with any entity type. Think of it as a simplified, general-purpose teleport.</p>
<p>If the targeted entity changes behavior when given a targetname, you can target its <strong>targetname2</strong> field instead.</p>

<h3 id="target_setsize">target_setsize</h3>
<p>Resizes the targeted entity's bounding box. Targets both <strong>targetname</strong> and <strong>targetname2</strong> fields.
The activator's bounding box can be changed as well by activating spawnflag 1.</p>

<h3 id="developer">Developer features</h3>
<ul>
	<li><strong>nomonsters</strong> cvar: if set to 1, the map will start with no monsters.</li>
	<li><strong>info_player_start_test</strong> entity: developer-only map start (requires <strong>developer 1</strong> cvar to be set). You can set a custom loadout for this specific point. Also it'll always pick the last one created in the map if there's more than one.</li>
	<li><strong>impulsetarget</strong> key: remote-control triggering. You can add a <strong>impulsetarget</strong> key to any entity and give it a value between 1 and 9, and it'll be triggered by the commands <strong>impulsetest1</strong> to <strong>impulsetest9</strong> (impulses 91 to 99). Useful to trigger some specific event in your map for testing purposes.</li>
	<li><strong>listmonsters</strong> command (impulse 184): lists all monsters left alive in the map and their current positions. Good to find out where's that last hiding monster that keeps you from getting 100% kills.</li>
	<li><strong>reveal</strong> command (impulse 200): Shows on the console information about the entity being pointed at. Only works with solid entities.</li>
</ul>

<h3 id="cheats">Cheats commands</h3>
<p>Besides the well-known Quake cheats, Alkaline adds some others.</p>
<p>Note that the old <strong>give #</strong> cheat to get a specific weapon won't work in this mod.</p>

<ul>
	<li><strong>resurrect</strong> (impulse 154): resurrects the player on the spot with 100 health and with their inventory intact.</li>
	<li><strong>giveall</strong> (impulse 9): Gives all weapons, ammo, keys, runes and armor.</li>
	<li><strong>giveweapons</strong> (impulse 13): Gives only weapons and ammo.</li>
	<li><strong>quad</strong> (impulse 255): Gives the Quad Damage.</li>
	<li><strong>belt</strong> (impulse 252): Gives the Invisibility Belt.</li>
	<li><strong>suit</strong> (impulse 253): Gives the Biosuit.</li>
	<li><strong>pentagram</strong> (impulse 254): Gives the Pentagram of Protection.</li>
</ul>

<hr>
<h2 id="thanks">Thanks</h2>

<p>To everyone responsible for the mods that we've gathered ideas and code from, especially Lunaran (Copper), dumptruck_ds (progs_dump), and sock (Arcane Dimensions). Alkaline wouldn't be what it is without your huge contributions to the Quake community.</p>
<p>To mr. John "metlslime" Fitzgibbons for creating Rubicon2 in the first place, and to ijed for the Rubicon Rumble Pack.</p>
<p>To Spike for the FTEQCC compiler and for being a walking encyclopedia regarding everything engine- and QuakeC-related.</p>
<p>To ericw for creating the awesome map compiling tools that were able to take modern Quake maps into another level in map complexity and lighting features.</p>
<p>To Preach, necros, czg, Kell and other modders of old, whose work led to where we are today in terms of modern mod features and monsters.</p>
<p>To the awesome community of mappers, modders and players at the Quake Mapping Discord, Quaddicted and func_msgboard for all the support and feedback.</p>

</body>
</html>
