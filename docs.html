<!DOCTYPE html>
<html>
<meta charset="utf-8">
<title>Alkaline Mapping Reference</title>
<style>
body {
	font-family: 'Helvetica', 'Arial', sans-serif;
	font-size: 1rem;
}
</style>
<head>
</head>

<body>

<h1>Alkaline Mapping Guide - v1.2.3</h1>
<h2>Contents</h2>
<nav>
<ul>
	<li><a href="#philosophy">Philosophy</a></li>

	<li>
		<a href="#monsters">Monsters</a>
		<ul>
			<li><a href="#monster-triggered-spawning">Triggered spawning</a></li>
			<li><a href="#monster-spawner">Monster spawner</a></li>
			<li><a href="#path-angry">Angry monsters' waypoints</a></li>
			<li><a href="#startpath">Follow a path upon an event</a></li>
			<li><a href="#autojump">Autojump</a></li>
			<li><a href="#monster-other-features">Other features</a></li>
			<li><a href="#target_infight">Entity target_infight</a></li>
			<li><a href="#monsters-list">Monsters list</a></li>
			<li><a href="#scientists">Scientists</a></li>
			<li><a href="#turrets">Turrets</a></li>
			<li><a href="#health-triggers">Health and wake triggers</a></li>
			<li><a href="#self-monsterjumps">Self-monsterjumps</a></li>
		</ul>
	</li>

	<li>
		<a href="#items">Items</a>
		<ul>
			<li><a href="#circuitboard">Circuitboard</a></li>
			<li><a href="#trifecta">Trifecta</a></li>
			<li><a href="#boots">Jump Boots</a></li>
			<li><a href="#shards">Armor Shards</a></li>
			<li><a href="#keys">Keys</a></li>
			<li><a href="#item-respawning">Item respawning</a></li>
			<li><a href="#item-trigger-spawning">Trigger spawning</a></li>
			<li><a href="#item-positioning">Item positioning</a></li>
			<li><a href="#item-style">Item box model style</a></li>
		</ul>

	</li>
	<li>
		<a href="#weapons">Weapons</a>
		<ul>
			<li><a href="#new-weapons">New weapons</a></li>
			<li><a href="#custom-loadout">Custom loadout</a></li>
			<li><a href="#axe-shotgun">Axe and shotgun pickups</a></li>
			<li><a href="#target_removeitems">target_removeitems entity</a></li>
			<li><a href="#particle-impact">Custom impact particle effect</a></li>
		</ul>
	</li>
	<li>
		<a href="#triggers">Triggers</a>
		<ul>
			<li><a href="#multiple-targets">Multiple targets</a></li>
			<li><a href="#dormant-triggers">Dormant triggers</a></li>
			<li><a href="#monster-triggerable">Monster-activated triggers</a></li>
			<li><a href="#message-all">Message all players</a></li>
			<li><a href="#relay-tricks">trigger_relay new tricks</a></li>
			<li><a href="#trigger_repeat">Repeater/timer trigger</a></li>
			<li><a href="#trigger_random">Random trigger</a></li>
			<li><a href="#monsterjumps">Monsterjumps</a></li>
			<li><a href="#hurt">Hurt triggers</a></li>
			<li><a href="#mapvars">Mapvars</a></li>
			<li><a href="#mapstart">Multiple map starting spots</a></li>
			<li><a href="#trigger_touchplate">Touchplate trigger</a></li>
			<li><a href="#mirror">Mirrors/reflections</a></li>
		</ul>
	</li>

	<li>
		<a href="#doors">Doors</a>
		<ul>
			<li><a href="#door-distance-angle">Distance and angle</a></li>
			<li><a href="#door-delay">Delayed movement</a></li>
			<li><a href="#door-linking">Door grouping/linking</a></li>
			<li><a href="#door-sounds">Sounds</a></li>
			<li><a href="#door-keys">Keys</a></li>
			<li><a href="#door-set-position">Setting a door position directly</a></li>
			<li><a href="#door-trigger-field">Trigger field</a></li>
		</ul>
	</li>

	<li>
		<a href="#plats">Plats</a>
		<ul>
			<li><a href="#plat-start-at-top">Plat start at top</a></li>
			<li><a href="#plat-toggle">Plat Toggle</a></li>
			<li><a href="#plat-elevator">Elevator</a></li>
			<li><a href="#plat2">Plat2</a></li>
			<li><a href="#other-plat-features">Other new features</a></li>
		</ul>
	</li>

	<li><a href="#trains">Trains</a>
		<ul>
			<li><a href="#modeltrain">Model trains</a></li>
		</ul>
	</li>

	<li>
		<a href="#teleports">Teleporters</a>
		<ul>
			<li><a href="#stealth-teleport">Stealth teleport</a></li>
			<li><a href="#multiple-destinations">Multiple teleport destinations</a></li>
		</ul>
	</li>

	<li>
		<a href="#state-system">State System</a>
		<ul>
			<li><a href="#state-triggers">Trigger brushes of any class</a></li>
			<li><a href="#state-doors">Doors</a></li>
			<li><a href="#state-buttons">Buttons</a></li>
		</ul>
	</li>

	
	<li>
		<a href="#advanced-triggering">Advanced triggering</a>
		<ul>
			<li><a href="#trigger_filter">trigger_filter</a></li>
			<li><a href="#trigger_everything">trigger_everything</a></li>
			<li><a href="#target_setcount">target_setcount</a></li>
			<li><a href="#damage-filters">Damage filters</a></li>
		</ul>
	</li>
	
	<li>
		<a href="#shadows">Shadows</a>
		<ul>
			<li><a href="#func_shadow">func_shadow entity</a></li>
			<li><a href="#switchable-shadows">Switchable shadows</a></li>
		</ul>
	</li>

	<li>
		<a href="#lights">Lights</a>
		<ul>
			<li><a href="#enhanced-light-toggling">Enhanced Toggling</a></li>
			<li><a href="#target_lightstyle">Setting a light's style directly</a></li>
			<li><a href="#new-light-fixtures">New light fixtures</a></li>
		</ul>
	</li>
	<li>
		<a href="#fog">Fog</a>
		<ul>
			<li><a href="#trigger_fogblend">Blending fog between two areas</a></li>
			<li><a href="#target_fogblend">Time-based fog blending</a></li>
			<li><a href="#skyfog">Sky fog</a></li>
		</ul>
	</li>
	<li>
		<a href="#solids">Solids</a>
		<ul>
			<li><a href="#liquids">Dynamic liquids</a></li>
			<li><a href="#breakables">Breakables</a></li>
			<li><a href="#togglable-brushes">Walls and togglable brushes</a></li>
			<li><a href="#misc_model">misc_model</a></li>
			<li><a href="#rotators">Rotators</a></li>
			<li><a href="#exploboxes">Exploboxes</a></li>
			<li><a href="#laser">Laser</a></li>
			<li><a href="#ladders">Ladders</a></li>
			<li><a href="#bobbing">Bobbing brushes</a></li>
			<li><a href="#func_fade">Fading brushes</a></li>
			<li><a href="#func_touchplate">Touchplate</a></li>
			<li><a href="#eased-movement">Eased movement</a></li>
		</ul>
	</li>

	<li>
		<a href="#sounds-music">Sounds and music</a>
		<ul>
			<li><a href="#triggered-sounds">Triggered sounds</a></li>
			<li><a href="#ambient-sounds">Ambient sounds</a></li>
			<li><a href="#music">Music</a></li>
		</ul>
	</li>

	<li>
		<a href="#environmental-effects">Environmental Effects</a>
		<ul>
			<li><a href="#void">Void</a></li>
			<li><a href="#gravity">Gravity</a></li>
			<li><a href="#gravity-pads">Gravity pads/floaters</a></li>
			<li><a href="#jump-pads">Jump Pads</a></li>
			<li><a href="#explosions">Explosions</a></li>
			<li><a href="#particle-field">Particle field</a></li>
			<li><a href="#lightning-trail">Lightning trail</a></li>
			<li><a href="#screen-shake">Screen shake</a></li>
			<li><a href="#text-story">Story texts</a></li>
			<li><a href="#other-effects">Other effects</a></li>

		</ul>
	</li>

	<li>
		<a href="#enhancements">Other Enhancements</a>
		<ul>
			<li><a href="#autosaves">Autosaves</a></li>
			<li><a href="#episode-ending">Episode-ending screen</a></li>
			<li><a href="#target_move">target_move</a></li>
			<li><a href="#developer">Developer features</a></li>
			<li><a href="#cheats">Cheats commands</a></li>
		</ul>
	</li>

	<li>
		<a href="#thanks">Thanks</a>
	</li>
</ul>
</nav>

<h2 id="philosophy">Philosophy</h2>

<p>
	Alkaline was originally built upon Rubicon 2 codebase. But over our development period, a great deal of code ended up being changed. Lots of new features, monsters, items, powerups, bug corrections... So it grew up into its own thing. We've borrowed ideas (or entire features altogether) from all the great mods and mod frameworks of our time. Copper, Arcane Dimensions, progs_dump, Zerstorer, Malice, Rubicon Rumble Pack, Quoth... you name it. Also we've got a bunch of exclusive features. Our main focus was on things that we felt would be nice to have in all kinds of base-themed maps.
</p>
<p>
	We've decided to not change anything gameplay-related. All original weapons, monsters and items behave almost exactly the way you've known and loved for the last 25 years. We think it's laudable what mods like Copper or AD have done to improve balance and gameplay, but our intention was to expand over the solid gameplay foundations that vanilla Quake laid, and add a load of new features and mapping quality-of-life enhancements on top of it.
</p>
<p>
	We'll do a more in-depth walkthrough into Alkaline's features, so any mapper can take it as a framework for their own map or mod. We've decided to go through everything that's been changed from vanilla instead of pure Rubicon 2, for an easier understanding.
</p>

<hr>

<h2 id="monsters">Monsters</h2>

<p>Monsters have a multitude of new features.</p>
<h3 id="monster-triggered-spawning">Triggered spawning</h3>
<p>By setting the <strong>Trigger Spawned</strong> spawnflag, the monster will only show up after it's been triggered. The following spawnflags can be used together with it:</p>

<ul>
<li><strong>Silent spawn</strong>: makes it spawn without making the teleport effect & sound, for when you need to repopulate an area out of the player's view.</li>
<li><strong>Spawn angry</strong>: spawns the monster already in alert state.</li>
<li><strong>Count after spawn</strong>: the monster adds to the map's total monster count only after it's been spawned in.</li>
</ul>

<h3 id="monster-spawner">Monster spawner</h3>
<p>
	Checking the <strong>Monster spawner</strong> flag turns this entity into a monster spawner, that creates a new instance of the monster whenever it's triggered. They always spawn angry, and have a telefrag check, so they may wait for a few seconds until they have room to spawn. The spawned monsters inherit all of the spawner entity's <strong>target*</strong> fields, so you can use it to add to a counter when they're killed for example.
	If you want it to spawn monsters in a defined time interval, you can set it up in conjunction with a <strong>trigger_repeat</strong>.
</p>
<p>The following keys are related to it:</p>

<ul><li><strong>totalspawncount</strong>: When set, the spawner will stop when it has spawned this amount of monsters. Also the total monster counter will start with this value already counted in, unless you set the <strong>Count after spawn</strong> flag as well. By default, it'll spawn monsters indefinitely.</li>
<li><strong>spawncount</strong>: Maximum amount of monsters spawned by this entity that can be alive at the same time (defaults to 10 monsters). If this value is reached, the monsters will stop spawning in from this entity until they're killed. Good for not overwhelming the player with a ludicrous amount of monsters in the same arena. Set to -1 if you want to disable this limit.</li>
</ul>

<h3 id="path-angry">Angry monsters' waypoints</h3>
<p>The <strong>path_angry</strong> point entity makes monsters follow a path automatically when angered for the first time, either by sight or trigger. They'll always follow the path up to its end, where they return to their normal movement behavior. While following this path, they can still see and attack you normally. It's useful when you need a monster to reliably come out of somewhere or run through complex pathways when angered, without randomly bumping into things while trying to get to you.</p>
<p>It works the same way as a path_corner, as in, you chain <strong>path_angry</strong> entities by their target/targetname fields to form a path, and make the monster target the first one - but it'll only act when the monster get angered or triggered.</p>
<p>Note that the chained <strong>path_angry</strong> entities must have an endpoint that doesn't target any other if you want the monster to get out of its path-chasing behavior. Also flying monsters don't work with it yet.</p>


<h3 id="startpath">Follow a path upon an event</h3>
<p>The <strong>target_startpath</strong> point entity makes a monster start following a path upon being triggered. Works with both path_corner and path_angry. <strong>target</strong> is the monster's name, and <strong>target2</strong> is the destination path.</p>

<p>If 'target2' is a path_corner, the monster will start walking towards it only when not angry. If it's a path_angry, on the other hand, it'll only do it while angry at something.</p>

<p>You can set up more than one target_startpath entity for a monster, if you need both walking/angry pathing situations to happen at different times. Or you can even have more than one of the same path type, if you want to route it to a different direction depending on some event.</p>

<h3 id="autojump">Autojump</h3>
<p>New in Alkaline is the autojump feature. Most walking monsters can automatically jump down from ledges or across small gaps to follow you, without the need for monsterjump triggers.</p>
<p>Various checks are made before the monster actually attempts to jump:</p>
<ul>
	<li>If there's room for the jump without hitting a wall or the ceiling;</li>
	<li>If it won't drop to a height below you;</li>
	<li>If it won't land on a non-walkable surface, like a steep slope, or on top of another monster.</li>
</ul>
<p>All walking melee monsters now do this by default, but you can control this behavior per-entity with the <strong>autojump</strong> key. A value of 1 forces it to on, and -1 to off. If you want to know whether a specific monster class has autojump enabled by default, just check the default value set on that key. Monsters without the key available in their keys list don't support autojump in any way, such as it's the case for large boss enemies and zombies for example, or any non-walking monster.</p>

<p>Autojump can also be controlled map-wide via the worldspawn key of the same name. 1 enables it for all autojump-supporting monsters in the map, and -1 disables for everyone, thus making everything return to the original behavior. Per-entity settings will always override this choice.</p>

<p>Keep in mind that this doesn't completely negate the need for trigger_monsterjumps in case you absolutely want a jump to occur at a specific spot, so don't be shy of still using them if you feel necessary.</p>

<h3 id="monster-other-features">Other features</h3>
<ul><li><strong>No sight sound</strong> flag: The monster won't make its sight sound when angry at something.</li>
<li><strong>No infight</strong> flag: The monster won't be angry at another when hit, only at players. Note that it doesn't prevent some other monster from getting angry at it, thus never giving it a chance to fight back.</li>
<li><strong>No idle sounds</strong> flag: The monster won't make any idle sounds when standing still. It'll still make sounds if walking/following path_corners though.</li>
<li><strong>Above</strong> key (flying monsters only): Specifies a height in units that a the monster will try to stay above the player, instead of always hover at its height.</li>
</ul>

<h3 id="target_infight">Infight trigger</h3>
<p>Point entity that makes <strong>target</strong> monster angry at <strong>target2</strong> when triggered.</p>
<p>If there are multiple monsters with the name indicated under <strong>target</strong>, they all will get angry at <strong>target2</strong>. <strong>target2</strong> on the other hand must point to a single entity, or else you'll get unpredictable results.</p>
<p>By default, the infighting doesn't start mutually, that is, <strong>target2</strong> monster will only get mad back at <strong>target</strong> after it's been attacked. If you want to make them angry at each other instantly, you can set the spawnflag <strong>Mutual hate</strong>.
</p>

<h3 id="monsters-list">Monsters list</h3>
<p>Last, but not least, here's the list of the baddies that come with Alkaline. The other non-base vanilla monsters not mentioned here behave and look the same, and they're all still available to use.</p>

<p>All of the original monsters whose visuals/sounds were modified (Death Knight, Scrag, Ogre and Fiend), are also available in their original versions, selectable through the spawnflag <strong>Original version</strong>.</p>

<ul>
	<li><strong>Grunt (monster_army):</strong> 30 HP</li>
	<li><strong>Nail Grunt (monster_nailgrunt):</strong> 30 HP</li>
	<li><strong>Rottweiler (monster_dog):</strong> 25 HP</li>
	<li><strong>Spiderbot (monster_spiderbot):</strong> 40 HP</li>
	<li><strong>Kamikaze Grunt (monster_kamikaze):</strong> 40 HP</li>
	<li><strong>Fast Zombie (monster_zombie2):</strong> 10 HP</li>
	<li><strong>Enforcer (monster_enforcer):</strong> 80 HP</li>
	<li><strong>Ogre (monster_ogre):</strong> 200 HP</li>
	<li><strong>Ogre Marksman (monster_ogre_marksman):</strong> 200 HP</li>
	<li><strong>Berserker (monster_ogreb):</strong> 200 HP</li>
	<li><strong>Axe Grunt (monster_axegrunt):</strong> 75 HP</li>
	<li><strong>Sabre Knight (monster_hell_knight):</strong> 250 HP</li>
	<li><strong>Dreadnaught (monster_dreadnaught):</strong> 150 HP</li>
	<li><strong>Centroid (monster_scourge):</strong> 300 HP</li>
	<li><strong>Eel (monster_eel):</strong> 25 HP</li>
	<li><strong>Frogman (monster_frogman):</strong> 100 HP</li>
	<li><strong>Drone (monster_drone):</strong> 100 HP</li>
	<li><strong>Centurion (monster_centurion):</strong> 150 HP</li>
	<li><strong>Probe (monster_probe):</strong> 200 HP</li>
	<li><strong>Grenade Probe (monster_grenadeprobe):</strong> 200 HP</li>
	<li><strong>Floyd Automaton (monster_floyd):</strong> 200 HP</li>
	<li><strong>Mega Enforcer (monster_me):</strong> 150 HP</li>
	<li><strong>Mutant (monster_mutant):</strong> 220 HP</li>
	<li><strong>Fiend (monster_demon1):</strong> 300 HP</li>
	<li><strong>Edie (monster_edie):</strong> 500 HP</li>
	<li><strong>Bambler (monster_bambler):</strong> 500 HP</li>
	<li><strong>Hunter (monster_hunter):</strong> 600 HP</li>
	<li><strong>Arachnofloyd (monster_arachnofloyd):</strong> 600 HP</li>
	<li><strong>Lieutenant (monster_super_enforcer):</strong> 120 HP + 1000 armor</li>
	<li><strong>Prowler (monster_rider):</strong> 600-777 HP</li>
	<li><strong>Annihilator (monster_banshee):</strong> 1300 HP</li>
	<li><strong>Tormentor (monster_tormentor):</strong> 2000 HP</li>
	<li><strong>Ogregon (monster_armagon):</strong> 2000-3500 HP</li>
</ul>

<h3 id="scientists">Scientists</h3>
<p>Poor scientists that have nothing to do with the Ranger's struggles through eldridtch dimensions. Deployed with the <strong>misc_scientist</strong> entity. They won't fight, just keep doing their jobs, or run aimlessly in panic. Select that behaviour through the spawnflag <strong>Ignore player</strong>.</p>
<p>Set <strong>wait</strong> and <strong>angle</strong> on path_corners for them to stop and work.</p>
<p>By default they won't count into total monster count, unless you set <strong>Count After Spawn</strong> flag.</p>

<h3 id="turrets">Turrets</h3>
<p>Ceiling-installed turrets, bearing menacing hitscan cannons. Place them with the <strong>monster_turret</strong> entity. If a player gets closer than 512 units, they'll deploy and start firing. If they lose sight of their target, they stay in an "active search" state for 30s, when they retract and go back to sleep. Activating the <strong>Don't sleep</strong> spawnflag prevents them from doing that.</p>
<p>Turrets don't count towards total monster count/kill.</p>

<h3 id="health-triggers">Health and wake triggers</h3>
<p>By activating the <strong>Health trigger</strong> spawnflag, the monster will fire <strong>target2</strong>, <strong>target3</strong> and <strong>target4</strong> when it takes 25%, 50% and 75% damage, respectively. Only <strong>target</strong> will be fired immediately when the monster dies in this case.</p>

<p>You don't have to assign targets to each health trigger level, just the ones you need. So, for example, you can ignore <strong>target2</strong> and <strong>target3</strong> if you only need a trigger to fire at 75% damage. Also, all assigned targets WILL fire when their thresholds have passed, even if they happen at the same frame - so if you insta-gib an enemy for example, all its remaining targets will be fired at the same time.</p>

<p>The <strong>Wake trigger</strong> spawnflag makes the monster fire <strong>target4</strong> upon getting angry for the first time. Note that using this in conjunction with health triggers prevents the 75% damage trigger from firing.</p>


<h3 id="self-monsterjumps">Self-monsterjumps</h3>
<p>Taken (stolen) from Copper, lets you set an initial velocity for when the first time a monster gets angry.</p>
<p>The <strong>movedir2</strong> key sets direct velocities relative to the monster's starting angle, in a "front right up" notation. So, for example, giving this field a value of "300 0 200" means the monster will be pushed with a velocity of 300 forward, and 200 upwards.</p>
<p><strong>movedir</strong> does the same, but based on absolute world coordinates.</p>


<hr>

<h2 id="items">Items</h2>

<p>Alkaline has some new items and item features.</p>

<h3 id="circuitboard">Circuitboard</h3>
<p>Deployed through the point entity <strong>item_circuitboard</strong>, the circuitboard (or rather the "17-centimeter Fromitz board") is a completely customizable dummy item that does nothing on its own, nor adds anything to your inventory. It merely fires its targets when picked up. But don't be fooled by its simplicity, because it's where lies all its power. You can use it to trigger any event, say, spreading various circuitboards throughout your map, all targeting the same trigger_counter, that unlocks a door or a super secret for example. Almost every map in Alkaline used it in some way.</p>
<p>You can set a custom model (<strong>mdl</strong> key), pickup sound file (<strong>noise</strong> key), and pickup name (<strong>netname</strong> key). By default the pickup text will be shown at the top of the screen like any other item, but if you want to suppress that and just centerprint a message instead, you can set the <strong>No pickup text</strong> flag and define the message in the <strong>message</strong> field.
</p>

<h3 id="trifecta">Trifecta</h3>
<p>
	The new awesome powerup in Alkaline. Gives you quad-damage, invincibility, and a mega health boost, all in one.
</p>

<h3 id="boots">Jump Boots</h3>
<p>
	This well-known powerup is available as well. Comes in two versions:
</p>
<ul>
	<li><strong>Persistent (item_jboots):</strong> always-on and upgradeable indefinitely. Each time one is picked up by a player, they get another jump charge. Also it's not removed from the inventory after a map change.</li>
	<li><strong>Timed (item_jboots_timed):</strong> Timed upgrade, available for 30s. By default it gives limitless charges, but you can change that through the <strong>jboots_rechargelimit</strong> key.</li>
</ul>
	
<h3 id="shards">Armor Shards</h3>
<p>Gives 5 armor points. It adds up to the player's current armor if it has one, and can go up to 25 points more than the armor type's maximum points. So, up to 125 for green armor, 175 for yellow, and 225 for red. If the player doesn't have any armor, it'll always count as green.</p>


<h3 id="keys">Keys</h3>

<p>Besides the standard Silver and Gold keys, there's also a new Platinum key (<strong>item_key3</strong>). It works the same way as the other keys. Due to engine limitations, it shows up on the HUD only in CSQC-supporting sourceports, but the basic functionality still works the same.</p>

<p>Buttons can now be set to require keys the same way as doors - just select the appropriate spawnflag.</p>

<p>Alkaline borrows the custom key system from progs_dump. You can create a key using the <strong>item_key_custom</strong> entity, and define a custom model, skin, sound and name. Then on any door you can set the name of the key that will open it. For more details, please refer to the in-editor documentation.</p>

<p>Also from progs_dump comes the <strong>trigger_usekey</strong> brush entity. You can use it to "consume" a key from the player's inventory (custom or not) and trigger some event - like a door would, but with no need for a door. It can be used by a player touching it, or by triggering.</p>

<h3 id="item-respawning">Item respawning</h3>
<p>Setting an item's <strong>ritem</strong> key to 1 makes it respawns after a few seconds, customizable through the <strong>respawndelay</strong> key. You also can set the maximum number of respawns through <strong>respawncount</strong>.</p>

<p>If the item is set to respawn, triggering it also makes it respawn instantly, while still respecting respawncount if that's set. Setting -1 on the <strong>respawndelay</strong> field makes the item never respawn automatically, thus being respawnable only through triggering.</p>

<p>By default, the item makes the traditional teleport sound/fog effect when respawning, but you can change it to the more discreet deathmatch-style respawn effect, through the spawnflag <strong>Spawn with DM effects</strong>.</p>

<h3 id="item-trigger-spawning">Trigger spawning</h3>
<p>Like monsters, items also support trigger-spawning. Just set the <strong>Trigger spawned</strong> flag and it'll only show up after triggered. You can make it spawn silently using the <strong>Spawn silent</strong> flag.
</p>

<h3 id="item-positioning">Item positioning</h3>
<p>The <strong>Suspended in air</strong> spawnflag makes the item stay in place and never drop to the floor, so it hovers in midair. Quoting Lunaran in a similar Copper feature:
	<blockquote>It's a useful hackaround for items that insist on falling out of the world and vanishing because they don't like where you placed them. This also provides a handy solution to the irritating problem that a monster and an item cannot overlap without pushing the item out of the world.
    Even if items don't fall out of the world when you test your map in your Quake engine port of choice, inconsistent droptofloor() results are not unheard of across ports. Consider it best practice to always mark as SUSPENDED any progression-critical items like keys, or any other item that fires a necessary targetname, even when placed on the ground.</blockquote>
</p>
<p>
	The <strong>Don't start dropped</strong> flag, on the other hand, makes the item to still be affected by gravity, but it will not spawn already dropped the floor directly below it (I.E. it won't run droptofloor() upon spawn). This way the item will fall to the floor only after it has been spawned.
</p>

<h3 id="item-style">Item box model style</h3>
<p>
	By default, Alkaline uses the higher-detail BSP item box models from Rubicon Rumble Pack, but you also have the option to use MDL item boxes by Markie - with proper fullbright parts so you can still see them in the dark. You can select it through the <strong>itemstyle</strong> key, either on worldspawn to set it globally, or directly on a per-entity basis.
</p>

<hr>

<h2 id="weapons">Weapons</h2>

<p>In your arsenal, some old acquaintances have made a return in Alkaline, but there's new stuff too.</p>

<h3 id="new-weapons">New weapons</h3>

<ul>
	<li><strong>Proximity Mine Launcher:</strong> </li>
	<li><strong>Laser Cannon:</strong> The good-old laser-ricochet chaos-inducing weapon from Scourge of Armagon makes a comeback in Alkaline.</li>
	<li><strong>Chainsaw:</strong> The chainsaw from Zerstörer, with a cool new model, animation and effects, if you like to get up close and personal with your foes.</li>
	<li><strong>Plasma Rifle:</strong> A completely new weapon! Not the most powerful energy weapon, but it's great for mowing down large groups of enemies as quickly as it mows down your cells.</li>
</ul>

<p>The Laser Cannon and the Plasma Rifle are placed in the same slot as the Lightning Gun, and alternate between them when you press their key, but can be selected directly through impulses <strong>225</strong> and <strong>227</strong>, respectively, so you can bind them to an individual key if you like. Also the Lightning Gun can be directly selected with the impulse code <strong>228</strong> without cycling through the other energy weapons.</p>
<p>The same happens to the Chainsaw, which sits along with the Axe, but can be directly selected through impulse <strong>224</strong>.</p>

<h3 id="custom-loadout">Custom loadout</h3>
<p>You can define a completely custom loadout at map start using the <strong>take_weapons</strong> and <strong>give_weapons</strong> worldspawn keys, as well as each of the ammo types.</p>
<p>First, Alkaline will remove the ones checked in <strong>take_weapons</strong>, then give the ones selected in <strong>give_weapons</strong>. So, if your map would begin with a "shotgun start" (I.E. default inventory), taking away the axe and the shotgun will make the player start with no weapons at all.</p>
<p>Setting any of the <strong>ammo_*</strong> keys will override the current amount with the defined one.</p>
<p>Also, setting the <strong>reset_items</strong> worldspawn key to 1 will force a "shotgun start" on your map regardless of inventory/stats coming from a previous map. Note that the inventory reset is made before applying take/give weapons.</p>

<h3 id="axe-shotgun">Axe and shotgun pickups</h3>
<p>Since you have the option to remove the axe and the shotgun from your inventory, we've added them as traditional weapon pickups as well. Deploy them through the <strong>weapon_axe</strong> and <strong>weapon_shotgun</strong> point entities.
</p>

<h3 id="target_removeitems">target_removeitems entity</h3>
<p>Acts the same way as the <strong>take_weapons</strong> worldspawn key, but can be used mid-level. Trigger it to remove the selected weapons from the activating player.</p>

<h3 id="particle-impact">Custom impact particle effect</h3>
<p>You can override the default particle effect when shot for every shootable entity, including monsters, breakables, buttons and doors. For that, you must manually add a <strong>bloodtype</strong> key to it, and give it one of the following values: </p>
<ul>
<li>1: Blood</li>
<li>2: Standard grey chunks</li>
<li>3: Brown dirt</li>
<li>4: Yellow sparks</li>
<li>5: White sparks</li>
</ul>


<hr>
<h2 id="triggers">Triggers</h2>

<p>In Alkaline we've gone great lengths to allow advanced scripting and events.</p>

<h3 id="multiple-targets">Multiple targets</h3>
<p>Following Copper's fashion, Alkaline also supports the <strong>target2/target3/target4</strong> keys but not multiple targetnames, as it increases code complexity and stack usage multi-fold. Having only multiple targets is usually enough to cover most cases, and you can always set up some relays if necessary.</p>

<p>An exception is made for some entities that must control or modify other entities that could have their behavior changed when given a targetname, so they can also target a <strong>targetname2</strong> field. Note that the targetname2 field isn't displayed on any entity by default, so you must add it manually when needed. The following entities have that ability:
</p>
	<ul>
		<li><strong>target_setstate</strong></li>
		<li><strong>target_setdoor</strong></li>
		<li><strong>target_move</strong></li>
		<li><strong>misc_shadowcontroller</strong></li>
	</ul>

<h3 id="dormant-triggers">Dormant triggers</h3>
<p>One of the first changes to triggers that every mod usually do is allow them to be trigger spawned, and with Alkaline that wouldn't be different. Set <strong>is_waiting</strong> to 1, and the trigger won't be active until you target it. It works with all touchable trigger brush entities.</p>

<h3 id="monster-triggerable">Monster-activated triggers</h3>
<p><strong>trigger_once</strong> and <strong>trigger_multiple</strong> can be set to be activated by monsters as well as players, so you can set them to fall into traps for example.</p>

<h3 id="message-all">Message all players</h3>
<p>Every entity that can centerprint a message may be set to broadcast it to all connected players. Good for when you have some map-wide event that you want to communicate in a co-op game for example. It's also useful if there's a chance that whoever's firing the trigger isn't a player, such as monster infighting kills. Just set the spawnflag <strong>message all players</strong> on the messaging entity.</p>

<h3 id="relay-tricks">trigger_relay new tricks</h3>
<p>trigger_relay got a few more features:</p>
<ul>
<li>The <strong>count</strong> key sets a maximum usage count. You can set it to 1 to make sure it can only be fired once.</li>
<li>The <strong>wait</strong> key sets a wait time after the last activation when it cannot be fired again. Works similar to a touch-less trigger_multiple.</li>
<li><strong>Not in nightmare</strong> flag.</li>
<li>The <strong>Fire automatically on map start</strong> flag does what it says on the tin. Good for firing map-start events, especially when used in conjunction with skill flags. If the relay is meant to be fired only this way, it doesn't need a targetname. </li>
<li><strong>Make sure activator is a player</strong> flag: if the activator isn't a player, change it to the closest one alive.</li>
<li><strong>Player only</strong> flag: Will only relay the firing if the activator is a player. Note that it'll always fire when used in conjunction with the flag above.</li>
</ul>

<h3 id="trigger_repeat">Repeater/timer trigger</h3>
<p>The <strong>trigger_repeat</strong> entity is a point entity that fires its targets repeatedly on a defined interval after activated. Can keep firing indefinitely or for a limited number of times. Targeting it again stops the firing.</p>
<p>The counter can be optionally not be reset after triggering it again (spawnflag 1), so it functions more like a pause/unpause.</p>

<h3 id="monsterjumps">Monsterjumps</h3>
<p>The <strong>trigger_monsterjump</strong> entity comes with some new features. You have now a simple monster-class-based filter, so you can let only a single monster class to be affected by it, or exclude a specific one from it.</p>

<h3 id="hurt">Hurt triggers</h3>
<p>The <strong>trigger_hurt</strong> brush entity works the same as before, but has 2 new features:</p>
<ul>
<li>Damage interval and amount can both be customized.</li>
<li>You can set it to not hurt players and/or monsters.</li>
</ul>


<h3 id="trigger_random">Random trigger</h3>
<p>For each of the 'target' fields, trigger_random will look for all entities with a matching targetname and fire only one entity at random. For example, if you have 'target' = 'myname', then it'll look for every entity in the map whose targetname is 'myname' and fire only one of them. </p>

<h3 id="monsterjumps">Monsterjumps</h3>
<p>The <strong>trigger_monsterjump</strong> entity comes with some new features. You have now a simple monster-class-based filter, so you can let only a single monster class to be affected by it, or exclude a specific one from it.</p>

<h3 id="hurt">Hurt triggers</h3>
<p>The <strong>trigger_hurt</strong> brush entity works the same as before, but has 2 new features:</p>
<ul>
<li>Damage interval and amount can both be customized.</li>
<li>You can set it to not hurt players and/or monsters.</li>
</ul>

<p>The new <strong>target_hurt</strong> entity is a point version of that. It hurts any entity activating it, or the entities defined in its target-target4 fields.</p>

<h3 id="mapvars">Mapvars</h3>
<p>Mapvars are miscellaneous flags (only true/false values) that can be freely used by the mapper whose values persist across level changes. Useful to track individual map completion progress on hub maps for example. You have a total of 69 flags availabe to use, each identified by a number in the 1-69 range.
</p>
<p>You can access them through 2 point entities:</p>
<ul>
<li><strong>trigger_mapvar_write</strong>: Writes a value to a specified mapvar. Can either set to on, to off, or toggle the current mapvar value.</li>
<li><strong>trigger_mapvar_read</strong>: Tests a mapvar against a specified value, and relays the trigger if the condition is met. When given a targetname, it'll do that only when triggered. Otherwise, it'll fire automatically once after the map starts - good for modifying map structures or enabling/disabling triggers right from the start.</li>
</ul>
<p>Besides these two entities, all triggers can be set a <strong>mapvar</strong> field pointing to a mapvar ID, so that the trigger will only fire if the specified mapvar is set to true.</p>

<p>You can also define a mapvar to be enabled automatically in <strong>trigger_changelevel</strong> entities when the player goes through it.</p>

<h3 id="mapstart">Multiple map starting spots</h3>
<p>You can have multiple player start spots in your map. <strong>trigger_changelevel</strong> entities accept a <strong>count</strong> key, which on the next map will try to direct the player to an <strong>info_player_start</strong> spot with a matching <strong>count</strong> value. That's also true for coop starts.</p>


<h3 id="trigger_touchplate">Touchplate triggers</h3>
<p></p>

<h3 id="mirror">Mirrors/reflections</h3>
<p>Generates a reflection of all point entities inside the trigger in the direction 'angle' is facing. Reflects monsters, projectiles, items, gibs, everything, except solid brush entities.</p>

<p>Level geometry needs to be duplicated manually. You can do this easily by making your room a single group in Trenchbroom, creating a linked duplicate, and mirroring it.</p>

<p>Only works with axial 'angle' values - 0/90/180/-90 for horizontal reflections, -1 for ceiling, and -2 for floor. The reflection will be generated at the face that 'angle' is pointing at.</p>

<p>If you have two trigger_mirror entities whose reflections are simultaneously visible, you need to give one of them a 'count' value of 2, otherwise you might have issues.</p>


<hr>
<h2 id="doors">Doors</h2>

<p>The good old <strong>func_door</strong> in Alkaline has been completely revamped.</p>

<h3 id="door-distance-angle">Distance and angle</h3>
<p>You have various ways of setting the door's movement:</p>
<ul>
<li>using the traditional <strong>angle</strong> and <strong>lip</strong> keys</li>
<li>using <strong>angle</strong>, but with <strong>distance</strong> instead of lip, to specify a travel distance directly</li>
<li>setting <strong>movedir</strong> as a direct distance vector ("x y z") relative to its initial position</li>
<li>setting <strong>mangle</strong> and <strong>distance</strong> to make it move in any arbitrary angle ("pitch yaw 0") and linear distance</li>
</ul>

<p>Note that those methods are mutually exclusive, so if you use one of those, remember to remove the keys relative to the others, or else you might have some unexpected behaviour.</p>

<p>You can now set a different closing speed for the door with the <strong>speed2</strong> key. If unset, it'll use the same value as <strong>speed</strong>.
</p>

<h3 id="door-delay">Delayed movement</h3>
<p>With this feature you can create more complex multi-entity doors with parts that move independently, but still act like a single door. You can set delayed movement for a door part with the <strong>delay</strong> key, and the timings are automatically reverted when closing, which means that the first door entity to open will be the last to close.</p>

<p><strong>delay2</strong> sets an additional delay for when the door closes. Useful if you need to wait for another door part to set in position before moving.</p>

<h3 id="door-linking">Door grouping/linking</h3>
<p>For the delayed movement feature to work as intended, a great deal of work was put into making sure they'll link correctly. By default, all doors whose bounding boxes touch or intersect will belong to a single group, and will always move at the same time. But now you also have the option to manually group them through the <strong>groupname</strong> key. Doors with this field set will ignore the touching algorithm for linking, and will only group with other doors that have the same groupname, regardless of where they're positioned in the map.</p>

<p>That also means that the old-time bug with toggling dual-doors was corrected, so you don't need to set "don't link" anymore for toggling doors.</p>

<p>It's recommended that you set the same key values on all doors in the group, like targets, wait, messages, keys, except those specific for each door part, like angle, distance, speed, delay, sound, etc.</p>

<h3 id="door-sounds">Sounds</h3>
<p>You can set completely custom sounds to doors. They'll override the default sounds selected through the <strong>sounds</strong> key (either on the door itself or on worldspawn).</p>
<ul>
	<li><strong>noise1</strong>: Sound file for the 'stop moving' sound</li>
	<li><strong>noise2</strong>: Sound file for the 'moving' sound (a looping sound file is recommended)</li>
	<li><strong>noise3</strong>: Sound file for the 'key required' sound</li>
	<li><strong>noise4</strong>: Sound file for the 'key used' sound</li>
</ul>
<p>
	Due to the new delayed movement features, the new spawnflag <strong>Sound during delay</strong> was added. When set, it'll make this specific door part to start its move sound at the instant the whole group starts moving, and only play the stop sound when all doors finished moving. This way you're able to set a single door in the group to sound during the whole movement sequence, and avoid multiple start/stop sounds overlapping for each entity.
</p>

<h3 id="door-keys">Keys</h3>
<p>You can set a door to demand a custom key through the <strong>keyname</strong> field. The keyname must match the one in a <strong>item_key_custom</strong> entity. Refer to the item_key_custom documentation in-editor for more details.</p>

<p>There are two other key-related options:</p>
<ul>
	<li><strong>cnt</strong> key: If set to 1, the player won't have the key removed from their inventory when unlocking, but the door will stay open as usual.</li>
	<li><strong>Doom style unlock</strong> spawnflag: Setting this allows the door to function like a conventional door (opens and closes) after it's been unlocked. It also makes players retain the key in their inventory.</li>
</ul>


<h3 id="door-set-position">Setting a door position directly</h3>
<p>The <strong>target_setdoor</strong> point entity can directly command a door to open or close, regardless of which state it's in. The <strong>style</strong> key sets the command issued to the targeted door when this entity is triggered. Note that doors with a wait time set will still close again normally afterwards.</p>
<p>If you need to command a door and still want it to retain its "touch to open" behavior, you can make the setdoor entity target the door's <strong>targetname2</strong> field..</p>

<h3 id="door-trigger-field">Trigger field</h3>
<p>The door's trigger field is the built-in trigger that makes the door open when something gets close to it. Alkaline gives you some more control over how it's created, or allows to make a completely custom one.</p> 
<p>The default door trigger field size in Quake extends 60 units beyond the whole door's bounding box in both X and Y directions. Through the spawnflags <strong>Expanded/reduced trigger field</strong>, you can set the trigger field to be expanded by another 24u, or reduced by 52u, in either X or Y direction. If you set both expand and reduce at the same time, they'll sum up, so you'll get a smaller reduction of 28u.</p>
<p>Also, you have the option of using the <strong>trigger_doortriggerfield</strong> brush entity. With it you can define a custom trigger field. Just make it target a door, and it'll override the built-in one.</p>
<p>Last but not least, standing monsters won't open doors anymore, so you can safely put an enemy ambushing behind one without it staying open.</p>

<hr>
<h2 id="plats">Plats</h2>

<p>Besides the traditional func_plat, we've added DoE's <strong>func_new_plat</strong> entity, which is a lot more flexible and feature-packed.</p>
<p>You can select between multiple plat modes through its spawn flags:</p>


<h3 id="plat-start-at-top">Plat start at top</h3>
<p>It's a plat that starts at the top and when triggered, goes down, waits, then comes back up. The <strong>health</strong> field sets the number of seconds to wait (default 5)</p>

<h3 id="plat-toggle">Plat Toggle</h3>
<p>Creates a plat that will change between the top and bottom each time it is triggered.</p>

<h3 id="plat-elevator">Elevator</h3>
<p>Makes an elevator plat. You can have as many levels as you want but they must be all the same distance away. Use the <strong>func_elvtr_button</strong> entity as the trigger. Each floor must have its own panel with func_elvtr_buttons for the elevator to move correctly.</p>

<p><strong>"Elevator Start at Top"</strong> is an optional flag for elevators. It just tells the elevator that it's position is the top floor. (Default is the bottom floor) USE THIS ONLY WITH ELEVATORS!</p>

<h3 id="plat2">Plat2</h3>
<p>'Plat2' is a fixed version of the original plat. If you want the plat to start at the bottom and move to the top on demand, use a negative height. That will tell Quake to lower the plat at spawn time. Always place this plat type in the top position when making the map. This will ensure correct lighting, hopefully. If a plat2 is the target of a trigger, it will be disabled until it has been triggered. Delay is the wait before the plat returns to original position.</p>

<h3 id="other-plat-features">Other new features</h3>

<p>The following features are present in both <strong>func_plat</strong> and <strong>func_new_plat</strong>:</p>
<ul>
	<li><strong>Custom sounds</strong>: can be set through the <strong>noise/noise1</strong> keys.</li>
	<li><strong>Deep trigger</strong> spawnflag: makes its trigger field go all the way to the bottom of the entity's lower position, instead of starting at the top of the lower position. For when you need to ride INSIDE of the plat entity's volume, not on top of it.</li>
</ul>

<hr>

<h2 id="trains">Trains</h2>

<p><strong>func_train</strong> have got some more tricks.</p>

<ul>
<li>Giving a <strong>path_corner</strong> a <strong>wait -1</strong> value will stop the train, and triggering the train again makes it resume its path.</li>

<li><strong>path_corner</strong> can change the train speed upon arriving at it.</li>

<li><strong>path_corner</strong> will have its targets fired when the train passes by.</li>

<li>Setting <strong>pausetime</strong> on the train sets a default waiting time when a value is not defined in path_corners.</li>

<li>Disabled path points (via a <a href="#state-system">target_setstate</a> entity) will be skipped by the train.</li>

<li>The train can be given custom sounds through the <strong>noise</strong> and <strong>noise1</strong> keys.</li>

<li><strong>Move on trigger</strong> spawnflag will force the train to resume its path when triggered, even when temporarily waiting at a path_corner.</li>

<li><strong>Stop on trigger</strong> spawnflag will stop the train at the next path_corner when triggered. Trigger it again to resume.</li>
</ul>
<p>The "Move on trigger"/"Stop on trigger" flags are mutually exclusive and will cause an objerror when selected simultaneously.</p>

<h3 id="modeltrain">Model trains</h3>
<p><strong>misc_modeltrain</strong> works the same way as a func_train, but for using with external models.</p>
<p>The model can smoothly orient itself towards the next path_corner when moving. The turning speed is automatic and based on the movement speed, but you can set a multiplier for the turning speed with the <strong>multiplier</strong> key. Set it to -1 to turn instantly.</p>
<p>You can define two different frame ranges and animation speeds, for when the model is stopped and moving. If you don't need different stopped/moving animations, only setting <strong>first_frame</strong>/<strong>last_frame</strong>/<strong>frtime</strong> is enough. If you don't need any animation at all, just set <strong>first_frame</strong> to the desired frame and all other fields can go blank.</p>
<p>Make sure to check the in-editor documentation for more details on other specific options.</p>


<hr>
<h2 id="teleports">Teleports</h2>

<h3 id="multiple-destinations">Multiple/random teleport destinations</h3>
<p>A single <strong>trigger_teleport</strong> can target multiple <strong>info_teleport_destination</strong> entities with the same targetname.</p>
<p>There are 3 ways in which the trigger can deal with that:</p>
<ul>
<li><strong>First</strong> mode (default): always selects the destination with the lowest <strong>count</strong> value. This way you can disable a specific destination with a <strong>target_setstate</strong> when you want the teleport to target the next one;</li>
<li><strong>Random</strong> mode: selects a destination randomly;</li>
<li><strong>Cycle</strong> mode: goes sequentially through destinations every time the teleport is used, according to their <strong>count</strong> field ordering.</li>
</ul>
<p>Refer to the in-editor documentation for both <strong>trigger_teleport</strong> and <strong>info_teleport_destination</strong> for more info.</p>


<h3 id="instant-teleport">Instant teleporters</h3>
<p>Alkaline now has instant teleporters, that seamlessly move whatever touches the trigger_teleport into another similar-sized brush entity, <strong>trigger_teleport_instadestination</strong>, instead of the info_teleport_destination point entity. It teleports everything - players, monsters, items, weapon projectiles, gibs and dead bodies - while keeping their angle and movement relative to the teleport's orientation - even pitch angle. This allows for huge amount of mind-bending scenarios.</p>
<p>Standard, point-entity based destination	teleports can also keep their relative entry angle and/or velocity by using the respective spawnflags into a <strong>info_teleport_destination</strong>.
</p>

<h3 id="stealth-teleport">Stealth teleport</h3>
<p>Stealth mode can be set on either <strong>trigger_teleport</strong> or <strong>info_teleport_destination</strong>. When that flag is set, the teleport effect/sound (AKA telefog) won't be spawned when something gets through.</p>
<p>Due to their nature, instant teleporters won't show a telefog by default, but you can force it back on by enabling the respective spawnflag into the <strong>trigger_teleport_instadestination</strong> entity.


<hr>

<h2 id="state-system">State System</h2>

<p>Alkaline has a state system somewhat similar to AD's "estate" system and Copper's target_lock entity. With it you can disable/enable entities at will, giving you greater control over complex map scripting and events. Entity behaviour when disabled is class-dependant.</p>
<p>You set an entity's state using the <strong>target_setstate</strong> point entity. You can directly disable, enable, or toggle the state. Target entities can start the map already disabled through the spawnflag <strong>Targets start disabled</strong>.</p>
<p>If you need to target an entity that has its behaviour changed when given a targetname (like <strong>func_door</strong> or <strong>trigger_teleport</strong>), you can make the <strong>target_setstate</strong> target the entity's <strong>targetname2</strong> field.</p>
<p>This system is integrated with dormant triggers (<strong>is_waiting</strong> key), meaning that you can "wake" a trigger not only by triggering it, but also by using a <strong>target_setstate</strong> on it.</p>
<p>The entity's state is kept under the <strong>estate</strong> field, which 0 meaning enabled/normal operation, and 1 disabled. So for triggers, you're able make them start off by to directly setting this value to 1. You cannot do that to doors nor buttons though, in those cases you need to use a target_setstate with "start disabled" set.</p>
<p>A lot of entities support enabling/disabling:</p>

<h3 id="state-triggers">Trigger brushes of any class</h3>
<p>When disabled, all <strong>trigger_*</strong> brush entities get their touch action turned off. This includes self-sufficient entities that don't need to target anything, like fog triggers, ladders, monsterjumps, changelevels, etc.</p>
<p>Also, any entity that fire their targets won't do it while disabled (like <strong>trigger_relay</strong>), and a <strong>trigger_counter</strong> won't get its use count increased.</p>

<h3 id="state-doors">Doors</h3>
<p>Like in Copper, disabling a door makes it not respond to touches or triggers, and disables its trigger field.</p>
<p>Doors will also close immediately when disabled. Togglable doors or with <strong>wait -1</strong> set won't close by default, but you can change that behaviour using the spawnflag <strong>Close all doors</strong>. In this case, if re-enabled, the door will return to the position it was before disabling.</p>

<h3 id="state-buttons">Buttons</h3>

<p>Also similar to Copper, buttons depress themselves when disabled and cannot be activated.</p>
<p>If the button have a <strong>wait -1</strong> value (that is, it's a press-once button), when re-enabled it'll reset back to its un-pressed state regardless if it had been activated before. You can change that using the spawnflag <strong>Don't reset button state</strong>, in which case it'll revert to its previous state when re-enabled.</p>



<hr>
<h2 id="advanced-triggering">Advanced triggering</h2>

<p>Alkaline has some very advanced scripting through some specialized entites.</p>

<h3 id="trigger_filter">trigger_filter</h3>
<p>This point entity relays only if a given condition evaluates to true, unleashing ultimate scripting capabilites. You can test various fields on the entity targeted by the <strong>include</strong> field (you can target another entity's <strong>targetname2</strong> as well). If you let the <strong>include</strong> field empty, it'll test against the activating entity instead, be it a player, a monster or anything else - see <strong>trigger_everything</strong> below for more details.</p>

<p>You can, for example, relay a trigger only if a door or plat is in a certain position, or if a targeted enemy is alive or dead or below a certain health amount, or if the player is carrying some specific weapon or item, or if the activator is a certain type of weapon projectile - the possibilites are almost endless.</p>

<p>In case you're filtering to activate only in case if it's a specific weapon projectile (like a grenade for example), you can make the targets fire with the activating entity's owner as the activator with the spawnflag <strong>Relay owner as activator</strong> - say, if the trigger is activated by a player's grenade, it'll fire with the player as activator, instead of the grenade itself.</p>

<p>There are various fields available to test, selectable through the <strong>style</strong> key. They all fall into three field types (float, flag and string), and for each there's a set of operations available to evaluate, selectable through the <strong>weapon</strong> key.</p>

<ul>
	<li>Float types can do all operations, and are compared to this entity's <strong>count</strong> field.</li>
	<li>Flag types support Equal and bitwise AND, and are compared to the <strong>aflag</strong> field.</li>
	<li>String types have only Equal evaluation, and are compared to this entity's <strong>type</strong> field.</li>
</ul>

<p>You can set the trigger to fire if the condition evaluates to false by activating the spawnflag <strong>Trigger if false</strong>. It'll never fire if the entity targeted by <strong>include</strong> isn't found, regardless of this spawnflag.</p>

<p>If you need to evaluate more than one condition, you can chain multiple filters in a row.
Also, the state of the last evaluation is stored in this entity's <strong>state</strong> field (1 for fired, 0 for not fired).</p>

<h3 id="trigger_everything">trigger_everything</h3>

<p>A no-holds-barred touchable solid trigger. Everything triggers it, such as players, monsters, projectiles, gibs, etc.</p>

<p>It can only fire targets matching its <strong>target</strong> field. Due to its "fire-all" nature, it doesn't have support for the 'target2-4' fields, neither 'message' nor 'killtarget'. Useful when used in conjunction with the <strong>trigger_filter</strong> point entity to filter out its firing.</p>

<p>By default it'll fire for each and every registered touch, even if simultaneous. If given a <strong>wait</strong> value, it'll act like a trigger_multiple, where a single activation puts it on hold for <strong>wait</strong> seconds. If the target is a trigger_filter, you can set it to wait only if the filter evaluates to true through the spawnflag <strong>Wait only if trigger_filter evaluates to true</strong>.</p>

<h3 id="target_setcount">target_setcount</h3>
<p>Changes the targeted entity's <strong>count</strong> field. Targets both targetname and targetname2 fields.
Can be used with a <strong>trigger_filter</strong> to dinamically change its float comparing value, or to reset/change a <strong>trigger_counter</strong>'s current use count.</p>

<p>You can either replace the current value with a new one, add to/subtract from it (using a positive or negative <strong>count</strong>), or toggle the current value between 0 and 1, by selecting into the <strong>style</strong> field.</p>

<h3 id="damage-filters">Damage filters</h3>
<p>Any damageable entity - be it shootable buttons, doors, breakables, or any monster - can filter out whatever entity is trying to hit them through a specially-set <a href="#trigger_filter">trigger_filter</a> entity. </p> 

<p>There are two ways of filtering, and for each you must add a speciic key pointing to the trigger_filter entity that will handle the filtering.</p>
<ul>
	<li><strong>Filter by attacker</strong>: the entity that's commanding the attack - a specific monster, or a player. You can filter out to a certain monster class for example, or only to player clients to successfully damage your target. Add an <strong>attackerfilter</strong> key pointing to the trigger_filter.</li>
	<li><strong>Filter by inflictor</strong>: the entity that's actually dealing the damage - usually a projectile, such as a spike, a grenade or a rocket. With it you can filter out a specific projectile type for example. Add an <strong>inflictorfilter</strong> key pointing to the trigger_filter.</li>
</ul>

<h4>Filter by attack type</h4>
<p>Another way to filter is by attack type. This is simpler to setup and doesn't require any trigger_filter entity.</p>
<p>All attacks in Alkaline are flagged with some attack type, as follows:</p>

<pre><code>float DMGTYPE_FALL = 2; // fall damage
float DMGTYPE_DROWN = 4; // damage from drowning
float DMGTYPE_LAVA = 8; // damage from lava liquid volumes
float DMGTYPE_SLIME = 16; // damage from slime liquid volumes
float DMGTYPE_BALLISTIC = 32; // shells and spikes and bullety things
float DMGTYPE_ENERGY = 64; // lightning, plasma, laser, blaster
float DMGTYPE_BURN = 128; // fire and hot stuff in general
float DMGTYPE_TOXIC = 256; // 
float DMGTYPE_CRUSH = 512; // crushing attacks, usually from movers
float DMGTYPE_MELEE = 1024; // melee attacks
float DMGTYPE_INSTANT = 2048; // void, telefrag
float DMGTYPE_EXPLOSION = 4096; // general explosions
float DMGTYPE_BURN_LONG = 8192; // same as burn but keeps on burning for a few seconds
</code></pre>

<p>By adding a <strong>damagedby</strong> key to your entity, and assigning one of the above flags to it (or a sum of values if you want more than one), the entity will only get hit by those attack types.</p>

<hr>
<h2 id="shadows">Shadows</h2>

<h3 id="func_shadow">func_shadow entity</h3>
<p><strong>func_shadow</strong> is a brush entity with a simple function: cast shadows. It's not visible nor clips nor does anything else ingame. In order for it to work correctly you need to either set a <strong>_shadow 1</strong> or a <strong>_switchableshadow 1</strong> key in it.</p>
<p>It's useful if you need to simulate a shadow being cast by a misc_model for example, or create more complex lighting schemes using switchable shadows (more on that below).</p>

<h3 id="switchable-shadows">Switchable shadows</h3>
<p>Alkaline has full-on support for switchable shadows if your compiling tools can handle it. Every brush entity, except triggers and <strong>func_detail_*</strong> ones, can have togglable shadows by adding a <strong>_switchableshadow 1</strong> key to it.</p>
<p><strong>func_door</strong>, <strong>func_breakable</strong> and <strong>toggle_visiblewall</strong> already have built-in support for that, so all you need to do is add the key for it to work automatically. Also, any killtargeted entity (like a <strong>func_wall</strong>) with a switchable shadow will have it removed automatically.</p>

<p>For other entity classes, like <strong>func_shadow</strong>, you need to set up a <strong>misc_shadowcontroller</strong> point entity to control their switchable shadows. That's how you do it:</p>
<ul>
	<li>Create a <strong>_switchableshadow</strong> key in the desired entity and set it to 1;</li>
	<li>Give it a <strong>targetname</strong> - if the entity changes behaviour when given a targetname, you can target a <strong>targetname2</strong> field instead.</li>
	<li>Create a <strong>misc_shadowcontroller</strong> entity targeting the bmodel, and give it a different targetname.</li>
	<li>Triggering the shadow controller toggles the shadow on/off with a fading animation.</li>
</ul>

<p>Currently, ericw's LIGHT tool supports switchable shadows only when the map isn't using bounce lighting. That's been already corrected in development versions however, and should be out in its next release.</p>
	
<hr>

<h2 id="lights">Lights</h2>

<p>
	Lights in Alkaline have some new notable features.
</p>

<h3 id="enhanced-light-toggling">Enhanced Toggling</h3>
<p>A feature brought over from progs_dump, animated lights (flickering/pulsing) can now be toggled. Give it a targetname as usual, but set the light style into the <strong>style2</strong> key. Then it'll toggle like any other light.</p>
<p>You can also set the light to fade it in/out when toggling by setting the spawnflag <strong>Fade in/out</strong>, and control the fading time with the <strong>speed</strong> key. Note that this effect won't work when toggling animated lights.</p>

<h3 id="target_lightstyle">Setting a light's style directly</h3>
<p>The <strong>target_lightstyle</strong> point entity can modify a light's style. It's the same one from Copper, so quoting its <a href="http://lunaran.com/copper/mapping/#target_lightstyle">docs</a> directly:</p>
<blockquote>
	<p>target_lightstyle gives the mapper direct control over the pattern of any of the 64 lightstyles when triggered. Styles 1-31 are the preset lightstyles, and 32-64 are assigned by the compiler to triggered lights, and both can be overridden. Set style to the lightstyle you want to override, and set message to the brightness pattern you want to set it to. If style is not set, and this entity targets any triggerable lights, it sets the brightness pattern of those lights when triggered instead. (Note that targeting anything at a light makes it a triggerable light with its own style automatically.) This is compatible with any Quake map compiler, because light.exe only cares about the style number - the pattern is only applied in-game.</p>

	<p>Setting style to -1 will override the style of all static, unstyled lights in the level (style 0).</p>

	<p>Multiple additional stylestrings can be specified in order using the noise and noise1-noise4 keyvalues. The target_lightstyle will cycle to the next unused one each time it is triggered.</p>

	<p>Quake's light patterns are sequences of characters where each letter represents a brightness from 0-200% lasting 0.1 seconds, allowing long animations to be packed into an editable string. a represents total darkness, m is normal brightness, and z is double brightness. For example, the painful disco strobe in the Fiend-filled corridor in E3M5, The Wind Tunnels, is "mamamamamama". Implementing a standard on/off toggle would use a message of "a" and a noise of "m" or "z".</p>
</blockquote>

<h3 id="new-light-fixtures">New light fixtures</h3>

<p>There are 2 new decorative light entities.</p>
<ul>
	<li><strong>light_fixture1</strong>: wall-mounted light fixture. Control the model's turning angle with the <strong>angle2</strong> field. Note that this angle won't be shown in the editor, only in-game.</li>
	<li><strong>light_beacon</strong>: Floor-mounted red beacon. Has an optional blinking animation, that syncs with light style 16.</li>
</ul>

<hr>

<h2 id="fog">Fog</h2>

<p>Alkaline comes with an improved version of Copper's dynamic fog system.</p>
<p>You can set a fog value into all player start entities, teleport destinations, and intermission cameras, so the fog will change instantly to the set value when a player makes use of them. This way, the player's view can move to a different fog zone without having to pass through a fog trigger.</p>
<p>An important note from Copper about this fog system:</p>
<blockquote>The fog keyvalue that goes on Worldspawn doesn't interact with this system. It is a feature of various engines (such as those in the Fitzquake family) and isn't interpreted by game code. The reason for this is that it's interpreted as four values (one for density and three for color) and set by the engine at load time. The numeric fields that are passed on to the game code (ie Copper), however, can only be one value (a float) or three (a vector). If you set fog in your world with a fog parameter on worldspawn, and never bother with fog_color and fog_density on any entities, you'll get the usual static global fog the way it's always worked. Color and density on a player start will be evaluated on the first frame of gameplay, and will override any fog set by the engine.</blockquote>
<p>Setting the fog density to -1 will disable the fog.</p>

<h3 id="trigger_fogblend">Blending fog between two areas</h3>
<p>Using the <strong>trigger_fogblend</strong> brush entity, you can smoothly blend between two fog values as the player moves across the trigger. It's not temporal-based, instead it's based on how far the player moves within it.</p>
<p>This way, you can place one along a corridor for example, and the fog will seamlessly change as the player walks.</p>

<h3 id="target_fogblend">Time-based fog blending</h3>
<p>The <strong>trigger_fog</strong> brush entity blends the player's current fog into another when touched, within a customizable transition time.</p>
<p>And the <strong>target_fogblend</strong> point entity toggles the activating player's fog between two different settings, also with a custom transition time. The first activation makes it blend in from the current fog, and the subsequent ones make it toggle between two values. You can optionally set the fog to be applied to all players.</p>

<h3 id="skyfog">Sky fog</h3>
<p>All entities that change the fog can change skyfog density as well, with the key <strong>skyfog_density/skyfog_density2</strong>. The same transitions to the usual fog apply to skyfog.</p>
<p>If you want to disable skyfog, set the field to -1. Leaving it unset, or set to 0, will keep the skyfog unchanged. In case you want to change only the skyfog density and not change the standard fog, set <strong>fog_density</strong> to 0.</p>

<hr>

<h2 id="solids">Solids</h2>

<h3 id="liquids">Dynamic liquids</h3>
<p>You can turn any solid brush, such as a togglable func_door or a func_train, into a dynamic liquid brush. Add a <strong>liquidbrush 1</strong> key to it and see the magic happens. You won't get the water warp screen effect while submerged, only the screen tint. Otherwise it should work as a normal liquid volume.</p>

<p>A limitation about this system is that the dynamic liquid brushes' area of influence is determined by their bounding boxes, instead of the actual geometry, just like triggers.</p>

<p>Adding a <strong>liquidtype</strong> key set to 1 turns it into slime, or into lava when set to liquidtype 2.</p>

<p>By default, the screen tint RBG values are the same as standard liquids on Quakespasm. You can override that through the <strong>liquidcolor</strong> key ("R G B" values in a 0-255 range), and the blend density through <strong>liquiddensity</strong> (also 0-255).</p>

<h3 id="breakables">Breakables</h3>
<p>A <strong>func_breakable</strong> is a visible object that can be destroyed by shooting it. If it has a targetname, it will only be destroyed by targeting it.</p>
<p>You have 4 debris variations, each with a different debris model and accompanying sound effect (<strong>style</strong> key).<p>
<p>A custom debris model can be set through the <strong>mdl</strong> key. You can also customize which particle effect will be spawned when the breakable get shot (<strong>bloodtype</strong> key).</p>
<p>If you want to drop an item out of a breakable, just make the func_breakable entity target a trigger-spawned item that has the "don't start dropped" flag checked as well. This way you can place the item "inside" the breakable brush without making it get stuck.</p>

<h3 id="togglable-brushes">Walls and togglable brushes</h3>
<p>There are 2 togglable brush entities:</p>
<ul>
	<li><strong>func_togglewall</strong>: Creates an invisible clipping wall that can be toggled on and off. Blocks movement and gunfire when active.</li>
	<li><strong>func_togglevisiblewall</strong>: A togglable, visible brush model. Besides the toggling mechanism, it functions like a func_wall in any other way. Can be set to be non-solid.</li>
</ul>

<h3 id="misc_model">misc_model</h3>
<p>You can add any custom model to your map through the <strong>misc_model</strong> entity to use as props or decoration. Targeting the entity toggles its visibility.</p>
<p>Any frame or skin can be selected. If the model doesn't animate automatically from a frame group, you can manually define a frame range and animation speed.</p>
<p>The model's bounding box can be totally customized by setting its size and center offset. Also it can be set to be affected by gravity and/or be solid.</p>


<h3 id="rotators">Rotators</h3>
<p>Alkaline comes with the well-known Hipnotic's rotate entities. The FGD descrition for the <strong>func_rotate_entity</strong> and <strong>func_rotate_door</strong> point entities have in-depth explanations on how to implement the whole setup.</p>
<p>You can also refer to <a href="https://tomeofpreach.wordpress.com/quoth/tutorial/rotation-overview/">czg's tutorial over Preach's Blog</a> on how to use them.</p>

<h3 id="exploboxes">Exploboxes</h3>
<p>Besides the usual <strong>misc_explobox</strong> point entities, there's a <strong>func_explobox</strong> brush entity that works exactly the same way but can be made in any shape.</p>
<p>Both <strong>misc_explobox</strong> and <strong>func_explobox</strong> fire their targets when exploding, and can be blown up remotely by triggering them.</p>

<h3 id="laser">Laser</h3>
<p>The <strong>func_laser</strong> brush entity creates a togglable laser with a faint flickering alpha effect. Hurts to touch, can be used to block players. We recommend to use it with a fullbright-colored texture for better looks.</p>

<h3 id="ladders">Ladders</h3>
<p><strong>trigger_ladder</strong> creates an invisible ladder entity. When player is touching it, they'll move in the direction they're facing when pressing forward. Also they can climb directly by pushing "jump".</p>
<p>The recommended way to set up a ladder trigger is to make it 16 units deep jutting out of whatever solid you're putting it up against. If you have a brushwork ladder on a wall, you can make that a func_illusionary or func_detail_illusionary and put the trigger covering it. Making the trigger too thin, or flush on a solid surface, will make it difficult for the player to climb up/down. We also recommend having the top of the trigger at the same height as the floor you want the player to step out to.</p>

<h3 id="bobbing">Bobbing</h3>
<p>You can create entities that gently move back and forth in any direction. <strong>func_bobbing</strong> is a brush entity, and <strong>misc_bobbing</strong> is a point entity that uses external models.</p>

<p>As of Alkaline 1.2.2, the old <strong>func_bob</strong> and <strong>misc_bob</strong> entities were deprecated in favor of Copper's implementation, which makes more sense to setup and doesn't have drift over time. Current maps set up with those entity classes still work with the newer progs, but they aren't available in the FGD anymore. In-game they get "converted" internally to the new func_bobbing/misc_bobbing, thus won't drift anymore either.</p>

<h3 id="func_fade">Fading brushes</h3>
<p><strong>func_fade</strong> is a non-solid entity that smoothly fades in/out. It has two operating methods: by proximity and by trigger.</p>

<h4>Proximity</h4>

<p>Default mode. The closer the player gets, the more visible the brush becomes, and vice versa.
<strong>waitmin</strong> sets the inner fade distance - in other words, if the player gets closer than that the brush will be totally visible. <strong>waitmax</strong> on the other hand defines the maximum distance before the brush fades away completely.</p>

<p>You can invert the close/far fading behavior with the "Reverse" spawnflag, so the brush will disappear as the player gets closer instead.</p>

<p>The <strong>target</strong> field can point to an entity to act as custom origin to check for player proximity. An info_notnull point entity can be used as target. If target is unset (or no entity is found under that name), the origin's coordinate will be the brush's midpoint.</p>


<h4>Trigger</h4>

<p>When given a <strong>targetname</strong>, it'll operate in trigger mode. Just target the func_fade entity to toggle it on/off. The fade time can be changed through the <strong>speed</strong> key.</p>

It can be set to start visible through the "Start on" spawnflag.
</p>

<h4>Other options</h4>

<p><strong>alpha</strong> and <strong>alpha2</strong> set the maximum and minimum visibility respectively, in a 0-1 range.</p>

<p>The <strong>target2</strong> field can be used to target a light entity, so it will fade in/out together with the brush.</p>

<p>If switchable shadows are on, they'll fade together as well.</p>

<h3 id="eased-movement">Eased movements</h3>
<p>You can have eased-out start and stop movements for func_train, func_door and func_plat by adding a <strong>smoothdist</strong> field to them. In that you set the distance from the start and before the end that the movement will accelerate/slow down. </p>

<hr>

<h2 id="sounds-music">Sounds and music</h2>
<p>The mod comes with various options for you to play your custom sounds.</p>

<h3 id="triggered-sounds">Triggered sounds</h3>
<p>Use the <strong>play_sound_triggered</strong> to plays an one-off sound when triggered.</p>
<p>The <strong>play_sound</strong> entity plays a sound on a periodic/random basis, like thunder effects for example. Not recommended for ambient sounds.</p>

<h3 id="ambient-sounds">Ambient sounds</h3>
<p>The <strong>ambient_general</strong> point entity lets you place a customized ambient sound. For it to work, make sure the sound file contains cue points for looping. Can be given customized volume and attenuation settings.</p>
<p>Also, the built-in <strong>ambient_*</strong> entities now can have their default volume/attenuations changed as well.</p>

<h3 id="music">Music</h3>
<p>The <strong>misc_changemusic</strong> entity changes the current map's music track number to the one specified in the <strong>sounds</strong> field when triggered. If you set the track to 1, the music will stop.</p>

<hr>
<h2 id="environmental-effects">Environmental Effects</h2>

<h3 id="void">Void</h3>
<p>The <strong>trigger_void</strong> brush entity removes from the world everything that touches it, such as monsters, items, gibs and weapon projectiles. Players get instantly killed, even while wearing the Pentagram or the Trifecta.</p>

<p>Also, the <strong>func_wall</strong> can be made non-solid, making it similar to a targetable func_illusionary.</p>


<h3 id="gravity">Gravity</h3>

<p>You can change the gravity in two ways:</p>
<ul>
	<li><strong>Globally:</strong> The <strong>trigger_globalgravity</strong> point entity toggles the world gravity between two settings when triggered (<strong>gravity</strong> and <strong>return_gravity</strong> fields).</li>
	<li><strong>Locally:</strong> The <strong>trigger_setgravity</strong> brush entity changes the gravity of each entity that touches it.</li>
</ul>


<h3 id="gravity-pads">Gravity pads/floaters</h3>

<p><strong>trigger_float</strong> makes things floaty. It pushes entities smoothly towards a set vertical speed, either up or downwards. Affects everything that has gravity - players, monsters, items, projectiles, gibs.</p>

<p>Can be given an optional float sound like trigger_push.</p>

<h3 id="jump-pads">Jump Pads</h3>

<p><strong>trigger_jumppad</strong> lets you set an info_notnull point entity as destination, and players and monsters will be thrown exactly at it, similar to Quaked 3's pads. The jump arc is calculated automatically in order to avoid any obstacles in the way in the best way possible. So you can set the destination to be on the other side of a high wall for example, and the jump will be in a high arc. You can manually tune the arc height with the <strong>height</strong> key, pushing it a bit higher (positive values) or lower (negative values) while still hitting the same spot. If there isn't any possible trajectory between the trigger and the destination, nothing will happen when the trigger gets touched.</p>

<p>By default, solid brush entities like doors and trains are ignored by the trajectory calculation, so the jumper will bump into them if they're in the way (say a closed door for example). If you want brush entities to affect the trajectory too and be avoided the same way as world brushes, you can check the "dodge brush entities" spawnflag.</p>

<p>The jump trajectory is calculated in real time, so it doesn't matter which part of the trigger is touched, the destination will always be the exact same spot. If you activate the "Fixed push direction" flag, no real time calculation will be done, and jump will be based on a fixed direction and height, precalculated on startup according to the offset between the info_notnull destination and the center of the trigger. This is useful if you have a wide jump pad trigger for example, and want its "landing area" to be as wide as the trigger instead of a single spot.</p>

<p>Due to how Quake physics work, jump pads apply a type of "constant push" to players along the whole jump arc until they bump into something, in order to try to emulate Quake 3's air control and keep them more or less on the intended trajectory, instead of being able to easily circle-strafe mid-air and change direction. You can disable this behavior with the "Don't hold player" spawnflag.</p>


<h3 id="explosions">Explosions</h3>
<p><strong>target_explosion</strong> creates explosions on demand, with the same appearance as a rocket/grenade blast. Can explode once on triggering, or be set to fire off on a periodic basis.</p>
<p>Damage can be customized - for reference, an Ogre's grenade blast does 40 damage, while a player's rocket hit deals 120 damage. Set it to 0 for a purely cosmetic effect.</p>

<h3 id="particle-field">Particle field</h3>
<p>The <strong>misc_particlefield</strong> brush entity makes dots appear continuously within its bounds. Trigger to toggle on/off.</p>

<h3 id="lightning-trail">Lightning trail</h3>
<p>You can create lightning trails using the <strong>misc_lightning_start</strong>, <strong>misc_lightning_relay</strong>, and <strong>misc_lightning_end</strong> point entities.</p>
<p>The trail always must start with a <strong>misc_lightning_start</strong> and end with a <strong>misc_lightning_end</strong>, but you can place some <strong>misc_lightning_relay</strong> between those if you need the trail to go into a different direction midway.</p>

<h3 id="screen-shake">Screen shake</h3>
<p><strong>target_screenshake</strong>, from <a href="http://lunaran.com/copper/mapping/#target_screenshake">Copper</a>:</p>
<blockquote>
	<p>Shakes the screen when triggered. Jostles the view of all clients, but doesn't physically move their bounding boxes or apply velocities. Set its intensity with <strong>strength</strong>. 1 is a hearty rumble, 10 is spasmodic bordering on hilarious.</p>

	<p>Follows an attack-sustain-release curve: it builds for <strong>delay</strong> seconds, holds at full strength for <strong>length</strong> seconds, then fades back toward zero for <strong>wait</strong> seconds. Total quake duration is therefore delay + length + wait. All three have defaults, but any of them can be forced to 0 by setting them to -1. (You might want a quake with no delay to be caused by a sudden blast, for example.)</p>
</blockquote>

<h3 id="text-story">Story texts</h3>
<p>To show long story texts, for logs, terminals, books, etc., you can use the <strong>trigger_textstory</strong> brush entity. It shows a message that remains on-screen while the player is inside the trigger volume. The screen background also gets a slighty dark tint, that can optionally be disabled through a spawnflag.</p>
<p>You can set it to be show the message only when the player is facing a certain angle within the trigger. Set the central angle with <strong>mangle</strong>, and the maximum angle offset with <strong>view_ofs</strong> (both in 'pitch way 0' format).</p>
<p>You can define custom sounds as well, both for when the message is shown (<strong>noise1</strong>) and when it fades away (<strong>noise2</strong>). Use "misc/talk.wav" for the default centerprint beep.</p>
<p>There's a point entity variant called <strong>target_textstory</strong>. When triggered, it'll show the message on-screen for the duration defined in <strong>wait</strong>. This variant gets the screen tint disabled by default, but it can be re-enabled through a spawnflag.</p>
<p>Story text entities also can have different messages according to a mapvar filter. Setting the <strong>mapvar</strong> field to it will make it show the text under <strong>message2</strong> when the specified mapvar is active.</p>


<h3 id="other-effects">Other effects</h3>
<ul>
	<li><strong>Trap shooters:</strong> Now can fire rockets, and have projectile speed and damage customized.</li>
	<li><strong>Laser turret:</strong> the <strong>func_turret</strong> brush entity creates a rotating laser shooter that aims at the player in any horizontal direction.</li>
	<li><strong>Smoke:</strong> From Rubicon2, there's the <strong>misc_smoke</strong> point entity. Produces a jet of smoke/steam. If targeted, it will toggle between on or off.</li>
	<li><strong>Fire/flames:</strong> the <strong>misc_flames</strong> produces a continuous stream of fire like a flamethrower. Toggles between on or off when targeted. If it targets a light, that light will be turned on while the flames are firing.</li>
	<li><strong>Sparks:</strong> the <strong>misc_sparks</strong>, also from Rubicon2. Produces a burst of yellow sparks at random intervals. If targeted, it will toggle between on or off.  If it targets a light, that light will flash allong with each burst of sparks.</li>
	<li><strong>Meat/gibs:</strong> <strong>target_meat_fireworks</strong>. Does what it says on the tin. Meat fireworks. Can be fired once or on a periodic basis.</li>
	<li><strong>Teleport fog:</strong> Targeting a <strong>target_telefog</strong> produces a teleport fog effect when triggered, sounds and all.</li>
	<li><strong>Particle splash:</strong> <strong>misc_splash</strong> produces a continuous particle splash for waterfalls.</li>
	<li><strong>Bullet holes:</strong> adding a <strong>nobullets</strong> with a value of 1 to any brush entity prevents it from getting bulletholes.</li>
	<li><strong>Skybox trigger:</strong> <strong>target_skybox</strong> changes the skybox for the activating player.</li>
</ul>

<hr>
<h2 id="enhancements">Other Enhancements</h2>

<h3 id="autosaves">Autosaves</h3>

<p>The <strong>target_autosave</strong> point entity saves the game when triggered, and does so by default in a slot named "auto". We've included a default bind for the F8 key that loads from this slot.</p>
<p>The same autosave entity can be used multiple times, so you don't need to place a new one for each save point if you don't want to.</p>

<h3 id="episode-ending">Episode-ending screen</h3>
<p>You can create a custom episode-ending screen by giving the <strong>trigger_changelevel</strong> a text into the <strong>message</strong> field.</p>
<p>Note that the screen width available only fits 40 characters at most, so you need to manually include line breaks (<strong>\n</strong>) into your text if necessary.</p>

<h3 id="target_move">target_move</h3>
<p>Using this point entity you can move any other entity to its origin upon triggering. Works with any entity type. Think of it as a simplified, general-purpose teleport.</p>
<p>If the targeted entity changes behavior when given a targetname, you can target its <strong>targetname2</strong> field instead.</p>
<p>Optionally it may spawn a teleport fog effect.</p>

<h3 id="target_setsize">target_setsize</h3>
<p>Resizes the targeted entity's bounding box. Targets both <strong>targetname</strong> and <strong>targetname2</strong> fields.
The activator's bounding box can be changed as well by activating spawnflag 1.</p>

<h3 id="developer">Developer features</h3>
<ul>
	<li><strong>nomonsters</strong> cvar: if set to 1, the map will start with no monsters.</li>
	<li><strong>info_player_start_test</strong> entity: developer-only map start (requires <strong>developer 1</strong> cvar to be set). You can set a custom loadout for this specific point. Also it'll always pick the last one created in the map if there's more than one.</li>
	<li><strong>impulsetarget</strong> key: remote-control triggering. You can add a <strong>impulsetarget</strong> key to any entity and give it a value between 1 and 9, and it'll be triggered by the commands <strong>impulsetest1</strong> to <strong>impulsetest9</strong> (impulses 91 to 99). Useful to trigger some specific event in your map for testing purposes.</li>
	<li><strong>listmonsters</strong> command (impulse 184): lists all monsters left alive in the map and their current positions. Good to find out where's that last hiding monster that keeps you from getting 100% kills.</li>
	<li><strong>reveal</strong> command (impulse 200): Shows on the console information about the entity being pointed at.</li>
	<li><strong>alkversion</strong> command (impulse 128): Prints the current Alkaline progs version.</li>
</ul>

<p>Besides the features above, the following console commands toggle specific Alkaline settings, and are more player-oriented. Note that these are all saved in the config file, so they persist across sessions.</p>
<ul>
	<li><strong>bulletholes</strong> (impulse 30): Toggles bullethole spawning for hitscan weapons and nails. Default on.</li>
	<li><strong>footsteps</strong> (impulse 31): Toggles player footstep sounds. Default on.</li>
	<li><strong>autosaves</strong> (impulse 32): Toggles mapper-placed autosaves. Default on.</li>
	<li><strong>tracers</strong> (impulse 42): Toggles bullet tracers for hitscan weapons. Default on.</li>
	<li><strong>playertracers</strong> (impulse 43): Toggles bullet tracers for the player weapons as well. Default off.</li>
	<li><strong>resetalkalinesettings</strong> (impulse 40): Resets all the options above to their default values.</li>
</ul>

<h3 id="cheats">Cheats commands</h3>
<p>Alkaline adds some new cheat commands.</p>
<p>Note that the old <strong>give #</strong> cheat to get a specific weapon won't work in this mod.</p>

<ul>
	<li><strong>resurrect</strong> (impulse 154): resurrects the player on the spot with 100 health and with their inventory intact. You also get a 5s invulnerability to get out of whatever rough spot you may have fall into.</li>
	<li><strong>giveall</strong> (impulse 9): Gives all weapons and ammo.</li>
	<li><strong>givekeys</strong> (impulse 13): Gives all 3 keys.</li>
	<li><strong>quad</strong> (impulse 255): Gives the Quad Damage.</li>
	<li><strong>belt</strong> (impulse 252): Gives the Invisibility Belt.</li>
	<li><strong>suit</strong> (impulse 253): Gives the Biosuit.</li>
	<li><strong>pentagram</strong> (impulse 254): Gives the Pentagram of Protection.</li>
	<li><strong>bootstimed</strong> (impulse 221): Gives the Super Jump Boots (timed with infinite charges).</li>
	<li><strong>boots</strong> (impulse 222): Gives the persistent Jump Boots, or upgrades it if you already have one.</li>
	<li><strong>bootsremove</strong> (impulse 223): Removes all jump boots and its upgrades.</li>

</ul>

<hr>
<h2 id="thanks">Thanks</h2>

<p>To everyone responsible for the mods that we've gathered ideas and code from, especially Lunaran (Copper), dumptruck_ds (progs_dump), and sock (Arcane Dimensions). Alkaline wouldn't be what it is without your huge contributions to the Quake community.</p>
<p>To mr. John "metlslime" Fitzgibbons for creating Rubicon2 in the first place, and to ijed for the Rubicon Rumble Pack.</p>
<p>To Spike for the FTEQCC compiler and for being a walking encyclopedia regarding everything engine- and QuakeC-related.</p>
<p>To ericw for creating the awesome map compiling tools that were able to take modern Quake maps into another level in map complexity and lighting features.</p>
<p>To Preach, necros, czg, Kell and other modders of old, whose work led to where we are today in terms of modern mod features and monsters.</p>
<p>To the awesome community of mappers, modders and players at the Quake Mapping Discord, Slipseer, Quaddicted and func_msgboard, for all the support and feedback.</p>

</body>
</html>
