//
// Quake game definition file (.fgd)
// for Worldcraft 1.6 and above
//
// written by autolycus / autolycus@planetquake.com
// email me with improvements and suggestions
//

// Modified by CZG : grawert@online.no : http://www.planetquake.com/greyvoid/

// Modified by Vigil for Rubicon 2
// Download Rubicon 2 from http://www.celephais.net
// Rubicon 2 created by John "metlslime" Fitzgibbons and Christian "CZG" Grawert
// Entity comments mostly copied from metlslime's rubicon2.def

//
// worldspawn
//

@SolidClass = worldspawn : "World entity"
[
	message(string) : "Text on entering the world"
	worldtype(choices) : "Ambience" : 0 =
	[
		0 : "Medieval"
		1 : "Runic (metal)"
		2 : "Present (base)"
	]
	sounds(integer) : "CD track to play" : 1
	light(integer) : "Ambient light"
	sky(string) : "Skybox"
	_dirt(integer) : "Use dirtmapping (ambient occlusion)" : 0
	_bounce(integer) : "Use bounce" : 0
	_bouncestyled(integer) : "Bounce styled lights" : 0
	_sunlight(integer) : "Sunlight"
	_sun_mangle(string) : "Sun mangle (Yaw pitch roll)"
	_sunlight_penumbra(integer) : "Specifies the penumbra width, in degrees, of sunlight. Useful values are 3-4 for a gentle soft edge, or 10-20+ for more diffuse sunlight." : 0
	_sunlight_color(color255) : "Sunlight Color" :  : "Specify the red(r), green(g) and blue(b) components for the colour of the sunlight. Default is white(255 255 255)." 
	_sunlight2(integer) : "Set the brightness of a dome of lights arranged around the upper hemisphere. (i.e. ambient light, coming from above the horizon). Default 0."
	fog(string) : "Fog Command" :  : "ENGINE only 'console command' for setting fog parameters, Density/R/G/B example = (0.05 0.3 0.3 0.3). NOTE- If you plan to use 'trigger_fog' in your map, be sure to set both INDIVIDUAL 'Fog Density' and 'Fog Colour' values for proper operation."
	fog_density(integer) : "Fog Density" :  : "Global fog density (def 0.1). NOTE - An Initial value MUST be entered for proper 'trigger_fog' operation."
	fog_colour(color1) : "Fog Colour" :  : "Initial global fog colour (def 0.1 0.1 0.1). NOTE - An initial value MUST be entered for proper trigger_fog operation."
]

//
// base marker definitions
//

@baseclass = Appearflags [
	spawnflags(Flags) =
	[
		256 : "Not in Easy" : 0
		512 : "Not in Normal" : 0
		1024 : "Not in Hard" : 0
		2048 : "Not in Deathmatch" : 0
	]
]

@baseclass = Targetname [ targetname(target_source) : "Name" ]
@baseclass = Target [ 
	target(target_destination) : "Target" 
	killtarget(target_destination) : "Killtarget"
]


@baseclass color(255 255 40) = Light [
	light(integer) : "Brightness" : 300
	wait(integer) : "Fade distance multiplier" : 1
	_color(color) : "Light color"
	mangle(string) : "Spotlight angle"
	angle(float) : "Spotlight angle width" : "40"
	_softangle(float) : "Inner spotlight angle width" : "0"
	delay(choices) : "Attenuation" =
	[
		0 : "Linear falloff (Default)"
		1 : "Inverse distance falloff"
		2 : "Inverse distance squared"
		3 : "No falloff"
	]
	style(Choices) : "Animated light style" : 0 =
	[
		0 : "Normal"
		10: "Fluorescent flicker"
		2 : "Slow, strong pulse"
		11: "Slow pulse, noblack"
		5 : "Gentle pulse"
		1 : "Flicker A"
		6 : "Flicker B"
		3 : "Candle A"
		7 : "Candle B"
		8 : "Candle C"
		4 : "Fast strobe"
		9 : "Slow strobe"
	]

	spawnflags(Flags) = [ 1 : "Initially dark" : 0 ]
]

@baseclass = ModelLight	[
	_minlight(integer) : "Min light" :  : "Set the minimum light level for any surface of the brush model. Default 0"
	_mincolor(color255) : "Min light color R G B" : "255 255 255" : "Specify red(r), green(g) and blue(b) components for the colour of the minlight. RGB component values are between 0 and 255 (between 0 and 1 is also accepted). Default is white light (255 255 255)"
	_shadow(integer) : "Shadows" :  : "If n is 1, this model will cast shadows on other models and itself (i.e. '_shadow' implies '_shadowself'). Note that this doesnâ€™t magically give Quake dynamic lighting powers, so the shadows will not move if the model moves. Func_detail ONLY - If set to -1, light will pass through this brush model. Default 0"
	_shadowself(integer) : "Self Shadow" :  : "If n is 1, this model will cast shadows on itself if one part of the model blocks the light from another model surface. This can be a better compromise for moving models than full shadowing. Default 0"
	_dirt(integer) : "Dirt mapping (override)" :  : "For brush models, -1 prevents dirtmapping on the brush model. Useful it the bmodel touches or sticks into the world, and you want to those ares from turning black. Default 0"
	_phong(choices) : "Enable Phong shading" : 0 =
	[
		0: "No"
		1: "Yes"
	]
	_phong_angle(integer) : "Phong shading angle" :  : "Enables phong shading on faces of this model with a custom angle. Adjacent faces with normals this many degrees apart (or less) will be smoothed. Consider setting '_anglescale' to '1' on lights or worldspawn to make the effect of phong shading more visible. Use the '-phongdebug' command-line flag to save the interpolated normals to the lightmap for previewing (use 'r_lightmap 1' or 'gl_lightmaps 1' in your engine to preview.)"
]

@baseclass = Alpha [
	alpha(float) : "Opacity" : 1 : "Controls entity opacity in the 0-1 range. 0: fully transparent, 1: fully opaque"
]

//
// Rubicon 2 specific additions
// New enemies have been added to the monster section
//

@SolidClass base(Appearflags, Targetname, Target) color(255 128 128) = func_explobox : 
"An exploding brush entity. Works just like misc_explobox." 
[
	health(integer) : "Health" : 20
	dmg(integer) : "Damage" : 100
	spawnflags(flags)=
	[
		1 : "Start off" : 0
	]
]

@SolidClass base(Appearflags, Targetname, Target) color(255 128 128) = func_breakable : 
"A visible object that can be destroyed by shooting it. If it has a targetname, it will not be directly damageable.

NO_MONSTERS: object ignores damage from monsters" 
[
	cnt(integer) : "Debris amount" : 6 : "Number of pieces of debris to spawn."
	health(integer) : "Health" : 20
	style(choices) : "Debris color" : 0 = 
	[
        0: "Green metal"
		1: "Red metal"
		2: "Concrete"
	]
	spawnflags(flags) =
	[
		1 : "No monsters" : 0
	]
]

// FUNC_LASER
// toggleable laser, damages on touch

@SolidClass base(Appearflags, Targetname, Target) color(255 128 128) = func_laser : 
"A togglable laser, hurts to touch, can be used to block players." 
[
	dmg(integer) : "Damage" : 1
	alpha(integer) : "Opacity" : 0.5 : "Approximate alpha you want the laser drawn at. default 0.5. alpha will vary by 20% of this value."
	message(string) : "Activated message"
	message2(string) : "Deactivated message"
	spawnflags(flags) =
	[
		1 : "Starts off" : 0
		2 : "Solid" : 0
	]
]

@SolidClass base(Appearflags, Targetname, Target) color(255 255 128) = func_turret : 
"A rotating laser shooter that aims at the player in any horizontal direction. Has a capped rotation speed based on skill setting. When triggered, toggles between active and inactive states.
START_OFF spawns in the inactive state.
Place in the level in the active/attacking position for proper lighting.
See Rubicon 2 for examples of use." 
[
	movedir(string) : "Active to start_off" : : "the offset from active position to the initial START_OFF position"
	movedir2(string) : "Active to deactive" : : "the offset from the active position to the deactivated position (after being previously active)"
	height(integer) : "Height" : 32 : "the position that laser originates, measured up from the very bottom of the model"
	speed(integer) : "Speed" : 100 : "speed when moving to a new position"
	sounds(choices) : "Sound" : 0 = 
	[
        0: "No sounds"
		1: "Stone"
		2: "Machine"
		3: "Stone Chain"
		4: "Screechy Metal"
	]
	spawnflags(flags) =
	[
		1 : "Starts off" : 0
	]
]


@SolidClass base(Appearflags, Targetname, Target) color(128 128 64) = trigger_ladder :
"Invisible ladder entity.
When player is touching this entity, he can climb by pushing 'jump'."
[
	angle(integer) : "Angle" : : "The direction player must be facing to climb ladder"
]

@PointClass base(Appearflags, Targetname, Target) color(0 128 0) size(-4 -4 -4, 4 4 4) = info_rotate : 
"Used as the point of rotation for rotatable objects." []

@SolidClass base(Appearflags, Targetname, Target) color(0 0 255) = func_movewall : 
"Used to emulate collision on rotating objects.
'Visible' causes brush to be displayed.
'Hurts' specifies whether to cause damage when touched by player.
'Non-solid' makes the brush non-solid.  This is useless if VISIBLE is set."
[
	dmg(integer) : "Damage" : 0
	spawnflags(flags) =
	[
		1 : "Visible" : 0
		2 : "Hurts" : 0
		4 : "Non-solid" : 0
	]
]

@SolidClass base(Appearflags, Targetname, Target) color(64 128 64) = func_rotate_door : 
"Creates a door that rotates between two positions around a point of rotation each time it's triggered.

STAYOPEN tells the door to reopen after closing.  This prevents a trigger-once door from closing again when it's blocked."
[
	dmg(integer) : "Damage" : 2 : "Specifies the damage to cause when blocked. Negative numbers indicate no damage."
	speed(integer) : "Speed" : 100 : "Specifies the time it takes to rotate."
	sounds(choices) : "Sound" =
	[
		0: "No sounds"
		1: "Stone"
		2: "Machine"
		3: "Stone Chain"
		4: "Screechy Metal"
	]
	spawnflags(flags) =
	[
		1 : "Stay open" : 0
	]
]

@SolidClass base(Appearflags, Targetname) color(64 128 64) = func_rotate_entity : 
"Creates an entity that continually rotates.  Can be toggled on and off if targeted."
[
	deathtype(string) : "Death message"
	rotate(integer) : "Speed" : 40
	target(string) : "Center of rotation"
	speed(integer) : "Acceleration" : 5 : "How long the entity takes to go from standing still to full speed and vice-versa."
	spawnflags(flags) =
	[
		1 : "Toggle" : 0
		2 : "Start on" : 0
	]
]


@SolidClass base(Appearflags, Targetname, Target) color(64 128 64) = func_rotate_train : 
"In path_rotate, set speed to be the new speed of the train after it reaches
the path change.  If speed is -1, the train will warp directly to the next
path change after the specified wait time.  If MOVETIME is set on the
path_rotate, the train to interprets 'speed' as the length of time to
take moving from one corner to another.

Both noise and noise1 defaults depend upon 'sounds' variable and
can be overridden by the 'noise' and 'noise1' variable in path_rotate.

Also in path_rotate, if STOP is set, the train will wait until it is
retriggered before moving on to the next goal.

Trains are moving platforms that players can ride.
'path' specifies the first path_rotate and is the starting position.
If the train is the target of a button or trigger, it will not begin moving until activated.
The func_rotate_train entity is the center of rotation of all objects targeted by it."
[
	noise(string) : "Stop sound"
	noise1(string) : "Start sound"
	sounds(choices) : "Sound" =
	[
		0 : "No sounds"
		1 : "Ratchet metal"
	]
	deathtype(string) : "Death message"
	speed(integer) : "Speed" : 100
	dmg(integer) : "Damage if blocked" : 0
	path(target_destination) : "Target path_rotate" : : "First path_rotate which will be the starting position"
]


@PointClass base(Appearflags, Targetname, Target) color(128 64 0) size(8 8 8) = path_rotate :
"Path for rotate_train.

ROTATION tells train to rotate at rate specified by 'rotate'.  Use '0 0 0' to stop rotation.

ANGLES tells train to rotate to the angles specified by 'angles' while traveling to this path_rotate.  Use values < 0 or > 360 to guarantee that it turns in a certain direction.  Having this flag set automatically clears any rotation.

STOP tells the train to stop and wait to be retriggered.

NO_ROTATE tells the train to stop rotating when waiting to be triggered.

DAMAGE tells the train to cause damage based on 'dmg'.

MOVETIME tells the train to interpret 'speed' as the length of time to take moving from one corner to another.

SET_DAMAGE tells the train to set all targets damage to 'dmg'

'noise' contains the name of the sound to play when train stops.
'noise1' contains the name of the sound to play when train moves.
'event' is a target to trigger when train arrives at path_rotate."
[
	spawnflags(flags) =
	[
		1 : "Rotation" : 0
		2 : "Angles" : 0
		4 : "Stop" : 0
		8 : "Waiting" : 0
		16 : "Damaging" : 0
		32 : "Movetime" : 0
		64 : "Target dmg" : 0
	]
	rotate(string) : "Speed (X Y Z)"
	angles(string) : "Angles (X Y Z)"
	dmg(integer) : "Damage" : 0
	noise(string) : "Stop sound"
	noise1(string) : "Start sound"
	event(string) : "Event target"
]

@PointClass base(Appearflags, Targetname, Target) color(0 128 204) = rotate_object :
"This defines an object to be rotated.  Used as the target of func_rotate_door." []


//
// player starts, deathmatch, coop, teleport
//

@baseclass base(Appearflags) size(-16 -16 -24, 16 16 32) 
	color(0 255 0) model({"path" :"progs/player.mdl"}) = PlayerClass [
		angle(integer) : "Angle"
	]

@PointClass base(PlayerClass) = info_player_start : "Player 1 start" []
@PointClass base(PlayerClass) = info_player_coop : "Player cooperative start" []
@PointClass base(PlayerClass) = info_player_start2 : "Player episode return point" []
@PointClass base(PlayerClass) = info_player_deathmatch : "DM start" []
@PointClass size(-16 -16 0, 16 16 64) base(Targetname) = info_teleport_destination : "Teleport destination" []
@PointClass = info_null : "info_null (spotlight target)"
[
	targetname(target_source) : "Name" 
]

@PointClass base(Target, Targetname) = info_notnull : "info_notnull" // I <3 you
[
	use(string) : "self.use"
	think(string) : "self.think"
	nextthink(integer) : "nextthink"
	noise(string) : "noise"
	wait(integer) : "wait"
]
@PointClass base(Appearflags) = info_intermission : "Intermission camera" 
[
	mangle(string) : "Mangle (Pitch Yaw Roll)"
]

//
// items
//
@baseclass color(80 0 200) base(Target, Targetname) = Item
[
	message(string) : "Message"
]
@baseclass size(0 0 0, 32 32 56) color(80 0 200) base(Item, Appearflags) = Ammo
[
	spawnflags(flags) = 
	[
		1 : "Large box" : 0
	]
]

@PointClass base(Ammo) model(
        {{
            spawnflags & 1 ->   ":maps/b_batt1.bsp",
                                ":maps/b_batt0.bsp"
        }}
    ) = item_cells : "Thunderbolt ammo" []
@PointClass base(Ammo) model(
        {{
            spawnflags & 1 ->   ":maps/b_rock1.bsp",
                                ":maps/b_rock0.bsp"
        }}
    ) = item_rockets : "Rockets" []
@PointClass base(Ammo) model(
        {{
            spawnflags & 1 ->   ":maps/b_shell1.bsp",
                                ":maps/b_shell0.bsp"
        }}
    ) = item_shells : "Shells" []
@PointClass base(Ammo) model(
        {{
            spawnflags & 1 ->   ":maps/b_nail1.bsp",
                                ":maps/b_nail0.bsp"
        }}
    ) = item_spikes : "Perforator/Nailgun ammo" []

@PointClass size(0 0 0, 32 32 56) base(Item, Appearflags) model(
        {{
            spawnflags & 2 ->   ":maps/b_bh100.bsp",
            spawnflags & 1 ->   ":maps/b_bh10.bsp",
                                ":maps/b_bh25.bsp"
        }}
    ) = item_health : "Health pak" 
[
	spawnflags(flags) = 
	[
		1 : "Rotten" : 0
		2 : "Megahealth" : 0
	]
]

@PointClass size(-16 -16 -24, 16 16 32) base(Item, Appearflags) model({ "path": ":progs/suit.mdl" }) =
	item_artifact_envirosuit : "Environmental protection suit" []
@PointClass size(-16 -16 -24, 16 16 32) base(Item, Appearflags) model({ "path": ":progs/quaddama.mdl" }) =
	item_artifact_super_damage : "Quad damage" []
@PointClass size(-16 -16 -24, 16 16 32) base(Item, Appearflags) model({ "path": ":progs/invulner.mdl" }) =
	item_artifact_invulnerability : "Pentagram of Protection" []
@PointClass size(-16 -16 -24, 16 16 32) base(Item, Appearflags) model({ "path": ":progs/invisibl.mdl" }) =
	item_artifact_invisibility : "Ring of Shadows" []


@PointClass size(-16 -16 0, 16 16 56) base(Item, Appearflags) model({ "path": ":progs/armor.mdl", "skin": 2 }) =
	item_armorInv : "Red armor (200%)" []
@PointClass size(-16 -16 0, 16 16 56) base(Item, Appearflags) model({ "path": ":progs/armor.mdl", "skin": 1 }) =
	item_armor2 : "Yellow armor (150%)" []
@PointClass size(-16 -16 0, 16 16 56) base(Item, Appearflags) model({ "path": ":progs/armor.mdl" }) =
	item_armor1 : "Green armor (100%)" []
@PointClass size(-16 -16 -24, 16 16 32) base(Item, Appearflags) model({ "path": ":progs/w_s_key.mdl" }) =
	item_key1 : "Silver key" []
@PointClass size(-16 -16 -24, 16 16 32) base(Item, Appearflags) model({ "path": ":progs/w_g_key.mdl" }) =
	item_key2 : "Gold key" []
@PointClass size(-16 -16 -24, 16 16 32) base(Item, Appearflags) model({ "path": ":progs/end1.mdl" }) =
	item_sigil : "Sigil"
[
	spawnflags(Flags) =
	[
		1 : "Episode 1" : 1
		2 : "Episode 2" : 0
		4 : "Episode 3" : 0
		8 : "Episode 4" : 0
	]
]

// ITEM_CIRCUITBOARD
// Collectible circuit board thingie

@PointClass base(Appearflags, Targetname, Target, Item) color(255 255 32) = item_circuitboard : "Circuit board" []


//
// weaponses
// added shotgun & axe for Rubicon 2
//

@baseclass size(-16 -16 0, 16 16 32) color(128 128 255) base(Item, Appearflags) = Weapon []

@PointClass base(Weapon) model({"path": "progs/g_axe.mdl"}) = weapon_axe : "Axe." []
@PointClass base(Weapon) model({"path": "progs/g_shotgn.mdl"}) = weapon_shotgun : "Shotgun." []
@PointClass base(Weapon) model({"path": "progs/g_shot.mdl"}) = weapon_supershotgun : "Super shotgun" []
@PointClass base(Weapon) model({"path": "progs/g_nail.mdl"}) = weapon_nailgun : "Nailgun" []
@PointClass base(Weapon) model({"path": "progs/g_nail2.mdl"}) = weapon_supernailgun : "Perforator" []
@PointClass base(Weapon) model({"path": "progs/g_rock.mdl"}) = weapon_grenadelauncher : "Grenade launcher" []
@PointClass base(Weapon) model({"path": "progs/g_rock2.mdl"}) = weapon_rocketlauncher : "Rocket launcher" []
@PointClass base(Weapon) model({"path": "progs/g_light.mdl"}) = weapon_lightning : "Thunderbolt" []

//
// badasses
// added enemies for Rubicon 2
//

@baseclass base(Appearflags, Target, Targetname) color(192 64 64) = Monster 
[
	spawnflags(Flags) = 
	[
		1 : "Ambush" : 0
		64 : "Spawned" : 0
		128 : "Silent" : 0
	]
]

// Rubicon 2 monsters first
// Centurion, 150 hp
@PointClass base(Monster) size(-32 -32 -24, 32 32 64) model({"path":"progs/cent.mdl"})= monster_centurion : "Centurion, 150 health points." []
// Dreadnaught, 150 hp
@PointClass base(Monster) size(-16 -16 -24, 16 16 40) model({"path":"progs/dread.mdl"}) = monster_dreadnaught : "Dreadnaught, 150 health points." []

@PointClass base(Appearflags, Target, Targetname) size(-32 -32 -24, 32 32 64) model({"path":"progs/floyd.mdl"}) = monster_floyd : "Floyd automaton robot, 200 hp
ROLLING Floyd is on his back and helpless, explodes after taking 75 damage
ASLEEP Floyd will not respond to anything unless he is shot or his targetname is triggered"
[
	spawnflags(flags) =
	[
		1 : "Ambush" : 0
		2 : "Rolling" : 0
		4 : "Asleep" : 0
	]
]

// Regular monsters
		
@PointClass base(Monster) size(-16 -16 -24, 16 16 40) model({"path":"progs/soldier.mdl"}) = monster_army :
"Grunt, 30 health points." []

@PointClass base(Monster) size(-32 -32 -24, 32 32 40) model({"path":"progs/dog.mdl"}) = monster_dog :
"Dog (Rottweiler), 25 health points." []

@PointClass base(Monster) size(-32 -32 -24, 32 32 64) model({"path":"progs/ogre.mdl"}) = monster_ogre :
"Ogre, 200 health points." []

@PointClass base(Monster) size(-32 -32 -24, 32 32 64) model({"path":"progs/ogrem.mdl"}) = monster_ogre_marksman :
"Ogre Marksman, 200 health points." []

@PointClass base(Monster) size(-16 -16 -24, 16 16 40) model({"path":"progs/knight.mdl"}) = monster_knight :
"Knight, 75 health points." []

@PointClass base(Monster) size(-16 -16 -24, 16 16 40) model({"path":"progs/hknight.mdl"}) = monster_hell_knight :
"Sabre Knight, 250 health points." []

@PointClass base(Monster) size(-16 -16 -24, 16 16 40) model({"path":"progs/wizard.mdl"}) = monster_wizard :
"Scrag (Wizard), 80 health points." []

@PointClass base(Monster) size(-32 -32 -24, 32 32 64) model({"path":"progs/demon.mdl"}) = monster_demon1 :
"Fiend (Demon), 300 health points." []

@PointClass base(Monster) size(-32 -32 -24, 32 32 64) model({"path":"progs/shambler.mdl"}) = monster_shambler :
"Shambler, 600 health points.
Rockets only have half damage
when hitting the Shambler." []

@PointClass base(Monster) size(-128 -128 -24, 128 128 256) model({"path":"progs/boss.mdl"}) = monster_boss :
"Chthon (Boss of Shareware Quake)
Only event_lightning can kill him." []

@PointClass base(Monster) size(-16 -16 -24, 16 16 40) model({"path":"progs/enforcer.mdl"}) = monster_enforcer :
"Enforcer, 80 health points." []

@PointClass base(Monster) size(-32 -32 -24, 32 32 48) model({"path":"progs/shalrath.mdl"}) = monster_shalrath :
"Vore (Shalrath), 400 health points." []

@PointClass base(Monster) size(32 32 48) model({"path":"progs/tarbaby.mdl"}) = monster_tarbaby :
"Spawn (Tarbaby), 80 health points." []

@PointClass base(Monster) size(32 32 48) model({"path":"progs/fish.mdl"}) = monster_fish :
"Rotfish, 25 health points." []

@PointClass base(Monster) size(-16 -16 -24, 16 16 32) model({"path":"progs/oldone.mdl"}) = monster_oldone :
"Shub-Niggurath, 40000 health points.
Most likely killed by teleport frag." []

@PointClass base(Monster) size(-16 -16 -24, 16 16 32) model({"path":"progs/zombie.mdl"}) = monster_zombie :
"Zombie, 60 health points.
If crucified, stick the bounding box 12 pixels back into a wall to look right." 
[
	spawnflags(Flags) = 
	[
		1 : "Crucified" : 0
		2 : "Ambush" : 0
	]
]



@PointClass base(Monster) size(-16 -16 -24, 16 16 40) model({"path":"progs/enforce3.mdl"}) = monster_super_enforcer :
"Lieutenant, 120 health points, 1000 armor.
This S.O.B. will turn you into Swiss cheese
if you are not careful!" []

@PointClass base(Monster) size(-16 -16 -24, 16 16 40) model({"path":"progs/enforce2.mdl"}) = monster_me :
"Mega Enforcer, 150 health points.
With a force field, plasma gun, and shoulder
cannon, look out for this cold-blooded killer." []

@PointClass base(Monster) size(-16 -16 -24, 16 16 40) model({"path":"progs/soldier.mdl", "skin": 1}) = monster_nailgrunt :
"Nail Grunt, 30 health points.
This ugly cyborg can penetrate your heart
...and not in a good way." []

@PointClass base(Monster) size(-16 -16 -24, 16 16 40) model({"path":"progs/axegrunt.mdl"}) = monster_axegrunt :
"Axe Grunt, 30 health points." []

@PointClass base(Monster) size(-32 -32 -24, 32 32 64) model({"path":"progs/scor.mdl"}) = monster_scourge :
"Centroid, 300 health points." []

@PointClass base(Monster) size(-48 -48 -24, 48 48 84) model({"path":"progs/armalegs.mdl"}) = monster_armagon :
"Armagon, 2000-3500 health points.
The big boss mam!" []

@PointClass base(Monster) size(-32 -32 -24, 32 32 64) model({"path":"progs/ogreb.mdl"}) = monster_ogreb :
"Berserker, 200 health points.
Don't shake hands with this crazy bastard!" []

@PointClass base(Monster) size(-16 -16 -24, 16 16 40) model({"path":"progs/drone1.mdl"}) = monster_drone :
"Drone, 100 health points." []

@PointClass base(Monster) size(-32 -32 -24, 32 32 64) model({"path":"progs/hunter.mdl"}) = monster_hunter :
"Hunter, maybe 375 health points." []

@PointClass base(Monster) size(32 32 48) model({"path":"progs/eel2.mdl"}) = monster_eel :
"Eel, 25 health points." []

//
// lights
//



@PointClass size(-8 -8 -8, 8 8 8) base(Light, Target, Targetname) = light : "Invisible lightsource"	[]
@PointClass size(-8 -8 -8, 8 8 8) base(Light, Target, Targetname) = light_fluoro : "Fluorescent light" []
@PointClass size(-8 -8 -8, 8 8 8) base(Light, Target, Targetname) = light_fluorospark : "Sparking fluorescent light" []
@PointClass size(-8 -8 -8, 8 8 8) base(Light, Target, Targetname) = light_globe : "Globe light" []

@PointClass size(-8 -8 -12, 8 8 20) base(Light, Target, Targetname) model({ "path": ":progs/flame2.mdl" }) = light_flame_large_yellow :
"Large yellow flame" []
@PointClass size(-4 -4 -12, 4 4 20) base(Light, Target, Targetname) model({ "path": ":progs/flame2.mdl" }) = light_flame_small_yellow :
"Small yellow flame" []
@PointClass size(-4 -4 -12, 4 4 20) base(Light, Target, Targetname) model({ "path": ":progs/flame2.mdl" }) = light_flame_small_white :
"Small white flame" []

@PointClass size(-4 -4 -12, 4 4 20) base(Light, Target, Targetname) model({ "path": ":progs/flame.mdl" }) = light_torch_small_walltorch :
"Small walltorch" []



@PointClass base(Appearflags, Targetname, Target, Light) size(-8 -8 -8, 8 8 24) model({"path":"progs/fixture1.mdl"})= light_fixture1 :
"Wall-mounted light fixture."
[
	angle2(string) : "Angle" : : "The angle the model should be facing; set it to face away from the wall"
]


@PointClass base(Appearflags, Targetname, Target, Light) size(-8 -8 -36, 8 8 8) model({"path": "progs/beacon.mdl"}) = light_beacon :
"Floor-mounted flashing red beacon
Set spawnflag 'Blinking' if you want the beacon to blink (set style to 16 to match the skin animation.)"
[
	angle2(string) : "Angle" : : "The angle the model should be facing; set it to face away from the wall"
	style(choices) : "Appearance" : 0 =
	[
		16 : "Match blinking animation"
	]
	spawnflags(flags) =
	[
		1 : "Blinking (also set style 16)" : 0
	]
]

//
// misc
//

@PointClass base(Appearflags, Name) = air_bubbles : "Air bubbles" []
@PointClass base(Appearflags, Targetname) = event_lightning : "Chthon's lightning" []

@PointClass size(0 0 0, 32 32 64) model({"path":"maps/b_explob.bsp"}) = misc_explobox : "Large nuclear container" []
@PointClass size(0 0 0, 32 32 32) model({"path":"maps/b_exbox2.bsp"}) = misc_explobox2 : "Small nuclear container" []

//@PointClass = func_illusionary2 : "Static model"  
//[
//	frame(integer)
//	model(string)
//]

@PointClass base(Targetname) color(220 150 150) = trap_spikeshooter : "Triggered shooter" 
[	
	angle(integer) : "Angle"
	spawnflags(Flags) = 
	[
		1 : "Superspike" : 0
		2 : "Laser" : 0
	]
]

@PointClass base(trap_spikeshooter) color(220 150 150) = trap_shooter : "Continuous shooter" [
	wait(integer) : "time between spikes (1.0 default)" : 1
	nextthink(integer) : "delay before firing first spike, so multiple shooters can be stagered"
]

@PointClass base(Appearflags) color(0 128 204) = misc_fireball : "Small fireball"
	[ speed(integer) : "Speed" : 40 ]

@PointClass base(Appearflags, Targetname, Target) color(0 128 204) = misc_sparks :
"Produces a burst of yellow sparks at random intervals. If targeted, it will toggle between on or off.  If it targets a light, that light will flash allong with each burst of sparks. 
Note: targeted lights should be set to START_OFF."
[
	wait(integer) : "Delay between sparks" : 2 : "Average delay between bursts (variance is 1/2 wait)."
	cnt(integer) : "Amount of sparks" : 15 : "Average number of sparks in a burst (variance is 1/4 cnt)."
	sounds(choices) : "Sounds" =
	[
		0 : "No sound"
		1 : "Spark sounds"
	]
	spawnflags(flags) =
	[
		1 : "Starts off" : 0
		2 : "Blue sparks" : 0
		4 : "Pale yellow sparks" : 0
	]
]

@PointClass base(Appearflags, Targetname, Target) color(0 128 204) = misc_smoke :
"Produces a jet of smoke/steam. If targeted, it will toggle between on or off."
[
	wait(integer) : "Time between puffs" : 1
	movedir(string) : "Initial velocity" : "0 0 250" : "A vector representing the initial velocity in X Y Z values. Default is '0 0 250' (up)"
	movedir2(string) : "Wind direction" : "0 0 0" : "a vector representing the wind in X Y Z values.  Default is '0 0 0'"
	dmg(integer) : "Damage" : 0 : "Amount of damage each puff gives on contact."
	sounds(choices) : "Sounds" =
	[
		0 : "No sounds"
		1 : "Steam hiss"
	]
	spawnflags(flags) =
	[
		1 : "Starts off" : 0
	]
]

@PointClass base(Appearflags, Targetname, Target) color(0 128 204) = misc_splash :
"Produces a continuous particle splash for waterfalls."
[
	color(integer) : "Color (0-15)" : 0 : "Color of particles.  0 through 15, corresponds to a row of the quake palette. (default 0)"
	movedir(string) : "Move vector (X Y Z)"
	wait(integer) : "Time between cycles" : 0.1
	volume(integer) : "Density" : 10
]

@PointClass base(Appearflags, Targetname, Target)  color(0 128 204) model(
	{"path":"progs/flag.mdl", "frame": spawnflags & 2}
) = misc_flag :
"A hanging banner, gently waving in the wind. Normal dimensions: 64 wide by 144 long.
Big banner is twice as big: 128 wide by 288 long."
[	
	spawnflags(flags) =
	[
		1 : "Not animated" : 0
		2 : "Big one" : 0
	]
]

@PointClass = viewthing :
"A model will be spawned at the position of this entity. (default = player)

Just for debugging. Don't use.

Use the console commands 'viewmodel', 'viewframe', 'viewnext', 'viewprev' to view frames of model."
[]

// 
// ambient sounds
// added Rubicon 2 ambient_general
//

@PointClass color(64 32 192) = ambient_general : "Ambient sounds"
[
	noise(string) : "File to play"
	volume(integer) : "Volume (0-1)" : 0.5
	speed(integer) : "Attenuation" : 3
]
@PointClass color(64 32 192) = ambient_drip : "Dripping sound" []
@PointClass color(64 32 192) = ambient_drone : "Engine/machinery sound" []
@PointClass color(64 32 192) = ambient_comp_hum : "Computer background sounds" []
@PointClass color(64 32 192) = ambient_flouro_buzz : "Fluorescent buzzing sound" []
@PointClass color(64 32 192) = ambient_light_buzz : "Buzzing sound from light" []
@PointClass color(64 32 192) = ambient_suck_wind : "Wind sound" []
@PointClass color(64 32 192) = ambient_swamp1 : "Frogs croaking" []
@PointClass color(64 32 192) = ambient_swamp2 : "Frogs croaking B" []
@PointClass color(64 32 192) = ambient_thunder : "Thunder sound" []

// 
// moving things
//


@SolidClass base(Appearflags, Targetname, Target, ModelLight) = func_door : "Basic door" 
[
	angle(integer) : "Angle" : : "determines the opening direction"
	speed(integer) : "Speed" : 100
	sounds(choices) : "Sound" : 0 = 
	[
        0: "No sounds"
		1: "Stone"
		2: "Machine"
		3: "Stone Chain"
		4: "Screechy Metal"
		5: "Custom sounds"
	]
	noise2(string) : "Move sound"
 	noise1(string) : "Stop sound"
	wait(string) : "Delay before close" : "4" 
	lip(integer) : "Lip" : 8
	dmg(integer) : "Damage inflicted when blocked" : 0
	message(string) : "Message if triggered"
	health(integer) : "Health (shoot open)" : 0
	spawnflags(flags) =
	[
		1 : "Starts Open" : 0
		4 : "Don't link" : 0
		8 : "Gold Key required" : 0
        16: "Silver Key required" : 0
        32: "Toggle" : 0
	]
]

@SolidClass base(Appearflags, Targetname, Target, ModelLight) = func_door_secret : "Triggered door" 
[
	angle(integer) : "Angle" : : "determines the opening direction"
	t_width(integer) : "First move lenght"
	t_length(integer) : "Second move lenght"
	dmg(integer) : "Damage when blocked" : 2
	wait(string) : "Time before close" : "2"
	sounds(choices) : "Sounds" : 3 =
	[
		1: "Medieval"
		2: "Metal"
		3: "Base"
	]
	message(string) : "Message"
	spawnflags(flags) = 
	[
		1 : "Open once only" : 0
		2 : "Moves left first" : 0
		4 : "Moves down first" : 0
		8 : "Not shootable" : 0
        16 : "Always shootable" : 0
	]
]

@SolidClass base(Targetname, Appearflags, ModelLight, Alpha) = func_wall : "Wall" []

@SolidClass base(ModelLight, Alpha) = func_illusionary : "Static model" []

@SolidClass base(Targetname, Target, ModelLight) = func_button : "When a button is touched, it moves some distance in the direction of it's angle, triggers all of it's targets, waits some time, then returns to it's original position where it can be triggered again." 
[
	
	speed(integer) : "Speed (units per second)" : 40
	lip(integer) : "Lip" : 4
	health(integer) : "Health (shootable if > 0)"
	sounds(choices) : "Sounds" = 
	[
		0 : "Steam metal"
		1 : "Wooden clunk"
		2 : "Metallic clink"
		3 : "In-out"
	]
	wait(string) : "Delay before reset" : "1"
	delay(string) : "Delay before trigger"
	message(string) : "Message" 
]

@SolidClass base(Targetname, ModelLight) = func_train :
"Trains are moving platforms that players can ride. The target's origin specifies the min point of the train at each corner. The train spawns at the first target it is pointing at.

Use path_corner as targets.
To stop a train entity, make the the last path_corner Wait -1.
If the train itself is the target of a button or trigger, it will not begin moving until activated.

Flags:
RETRIGGER: stop at each path_corner and don't resume until triggered again (ignores wait time)
" 
[
	sounds(choices) : "Sound" : 1 =
	[
		0: "None"
		1: "Ratchet Metal"
	]
	speed(integer) : "Speed (units per second)" : 100
	target(target_source) : "First stop target"
	dmg(integer) : "Damage on crush" : 2
	spawnflags(flags) =
	[
		1: "Retrigger" : 0
	]
]

@PointClass base(Targetname) color(128 64 0) size(8 8 8) = path_corner :
"Moving platform stop"
[
	target(target_source) : "Next stop target"
	wait(integer) : "Wait" : 0
]

@SolidClass base(Targetname, ModelLight) = func_plat :
"Plats are always drawn in the extended position, so they will light correctly.

If the plat is the target of another trigger or button, it will start out disabled in the extended position until it is triggered, when it will lower and become a normal plat.

Flags:
low_trigger: plat will only be triggered when in lowered position" 
[	
	spawnflags(Flags) =
	[
		1 : "Low trigger" : 0
	]
	speed(integer) : "Speed" : 150
	height(integer) : "Travel altitude (can be negative)" : 0
	sounds(choices) : "Sound group" : 1 =
	[
		0: "None"
		1: "Base fast"
		2: "Chain Slow"
	]
]	

@SolidClass = func_episodegate : "Episode Gate"
[
	spawnflags(Flags) =
	[
		1 : "Episode 1" : 1
		2 : "Episode 2" : 0
		4 : "Episode 3" : 0
		8 : "Episode 4" : 0
	]
]

@SolidClass = func_bossgate : "Boss gate" []

//
// triggers
//

@baseclass color(128 0 128) base(Target, Targetname) = Trigger
[
	sounds(choices) : "Sound style" : 0 =
	[
		0 : "None"
		1 : "Secret sound"
		2 : "Beep beep"
		3 : "Large switch"
		4 : "Set message to text string"
	]
	delay(string) : "Delay before trigger" : "0"
	message(string) : "Message (set sound too!)"
]

@SolidClass= trigger_changelevel : "Trigger: Change level"
[
	map(string) : "New map name"
	target(target_destination) : "Target"
	spawnflags(flags) =
	[
		1: "No Intermission" : 0
	]
]

@SolidClass base(Trigger) = trigger_once : "Trigger: Activate once"
[
	health(integer) : "Health"
	spawnflags(flags) = [ 1: "Entity only" : 0 ]
]
@SolidClass base(Trigger) = trigger_multiple : "Trigger: Activate multiple" 
[
	wait(string) : "Wait before reset" : "4"
	health(integer) : "Health"
	spawnflags(flags) = [ 1: "Entity only" : 0 ]
]
@SolidClass base(Trigger) = trigger_onlyregistered : "Trigger: Registered only" 
[
	spawnflags(flags) = [ 1: "Entity only" : 0 ]
]
@SolidClass base(Trigger) = trigger_secret : "Trigger: Secret" 
[
	sounds(choices) : "Sound style" : 1 =
	[
		0 : "None"
		1 : "Secret sound"
		2 : "Beep beep"
		3 : "Large switch"
		4 : "Set message to text string"
	]
	spawnflags(flags) = [ 1: "Entity only" : 0 ]
]

@SolidClass base(Target, Targetname) = trigger_teleport : "Trigger teleport" 
[
	spawnflags(Flags) =
	[
		1 : "Player only" : 0
		2 : "Silent" : 0
	]
]

// need updates:

@SolidClass = trigger_setskill : "Trigger set skill" 
[
	message(choices) : "Skill to change to" : 1 =
	[
        0 : "Easy"
        1 : "Medium"
        2 : "Hard"
        3 : "Nightmare!"
	]
]
@PointClass base(Trigger) = trigger_relay : "Trigger relay"
[
]
@SolidClass base(Targetname) = trigger_monsterjump : "Trigger monster jump" 
[
	speed(integer) : "Jump Speed" : 200
	height(integer) : "Jump Height" : 200
	angle(integer) : "Angle"
]
@PointClass base(Trigger, Target, Targetname) = trigger_counter : "Trigger counter" 
[
	spawnflags(flags) = [ 1: "No Message" : 0 ]
	count(integer) : "Count before activation" : 2
]
@SolidClass base(Targetname) = trigger_push : "Trigger player push"
[
	angle(integer) : "Angle"
	spawnflags(flags) = [ 1: "Once Only" : 0 ]
	speed(integer) : "Speed of push" : 1000
]
@SolidClass  base(Targetname) = trigger_hurt : "Trigger player hurt" 
[
	dmg(integer) : "Damage" : 5
	wait(integer) : "Delay before reset"
	message(string) : "Message"
]

